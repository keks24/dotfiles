#############################################################################
# Copyright 2020-2025 Ramon Fischer                                         #
#                                                                           #
# Licensed under the Apache License, Version 2.0 (the "License");           #
# you may not use this file except in compliance with the License.          #
# You may obtain a copy of the License at                                   #
#                                                                           #
#     http://www.apache.org/licenses/LICENSE-2.0                            #
#                                                                           #
# Unless required by applicable law or agreed to in writing, software       #
# distributed under the License is distributed on an "AS IS" BASIS,         #
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  #
# See the License for the specific language governing permissions and       #
# limitations under the License.                                            #
#############################################################################

# functions
## translate words (english-german,german-english)
dic()
{
    local input_string="${*}"

    # rudimentary url encoding
    # cascade through all cases via ";|"
    case "${input_string}" in
        *" "*) input_string="${input_string// /+}" ;|

        *\!*) input_string="${input_string//\!/%21}" ;|
        *\"*) input_string="${input_string//\"/%22}" ;|
        *\#*) input_string="${input_string//\#/%23}" ;|
        *\$*) input_string="${input_string//\$/%24}" ;|
        *\&*) input_string="${input_string//\&/%26}" ;|
        *\'*) input_string="${input_string//\'/%27}" ;|
        *\(*) input_string="${input_string//\(/%28}" ;|
        *\)*) input_string="${input_string//\)/%29}" ;|

        *\@*) input_string="${input_string//\@/%40}" ;|
        *\`*) input_string="${input_string//\`/%60}" ;|

        *\**) input_string="${input_string//\*/%2A}" ;|
        *\,*) input_string="${input_string//\,/%2C}" ;|
        *\/*) input_string="${input_string//\//%2F}" ;|

        *\:*) input_string="${input_string//\:/%3A}" ;|
        *\;*) input_string="${input_string//\;/%3B}" ;|
        *\<*) input_string="${input_string//\@/%3C}" ;|
        *\=*) input_string="${input_string//\=/%3D}" ;|
        *\>*) input_string="${input_string//\@/%3E}" ;|
        *\?*) input_string="${input_string//\?/%3F}" ;|

        *\[*) input_string="${input_string//\[/%5B}" ;|
        *\\*) input_string="${input_string//\\/%5C}" ;|
        *\]*) input_string="${input_string//\]/%5D}" ;|
        *\^*) input_string="${input_string//\^/%5E}" ;|

        *\{*) input_string="${input_string//\{/%7B}" ;|
        *\|*) input_string="${input_string//\|/%7C}" ;|
        *\}*) input_string="${input_string//\}/%7D}" ;|

        *\ß*) input_string="${input_string//\ß/%C3%9F}" ;|
        *\ä*) input_string="${input_string//\ä/%C3%A4}" ;|
        *\§*) input_string="${input_string//\§/%C2%A7}" ;|
        *\°*) input_string="${input_string//\°/%C2%B0}" ;|
        *\²*) input_string="${input_string//\²/%C2%B2}" ;|
        *\³*) input_string="${input_string//\³/%C2%B3}" ;|
        *\´*) input_string="${input_string//\´/%C2%B4}" ;|
        *\ö*) input_string="${input_string//\ö/%C3%B6}" ;|
        *\ü*) input_string="${input_string//\ü/%C3%BC}" ;|

        *\€*) input_string="${input_string//\€/%E2%82%AC}" ;;
    esac

    local dictionary_url="https://pocket.dict.cc/?s=${input_string}"

    \echo -e "URL: ${dictionary_url}\n"

    local curl_output=$(
                        \curl \
                            --silent \
                            --show-error \
                            --url "${dictionary_url}"
                       )

    if [[ "${curl_output}" == *"No results!"* ]]
    then
        local no_results="true"
    fi

    local filtered_output=$(
                            \gawk \
                                '/<dl>|<\/dl>|<dt>|<\/dt>|<dd>|<\/dd>/ \
                                {
                                    # remove title tag
                                    gsub("<dt>", "");

                                    # add newline and indent
                                    gsub("<br>|<br />", "\n    ");

                                    # indent sub entries
                                    gsub("<dd>", "\n    ");

                                    # remove div container block
                                    gsub("<div.*>(.|\n)*</div>", "");

                                    # remove javascript block
                                    gsub("<script.*>(.|\n)*</script>", "");

                                    # remove any other html tags
                                    gsub("<[^>]+>", "");

                                    # reconstruct special characters (https://www.w3schools.com/html/html_entities.asp)
                                    ## non-breaking space
                                    gsub("&nbsp;", " ");

                                    ## lower than
                                    gsub("&lt;", "<");

                                    ## greater than
                                    gsub("&gt;", ">");

                                    ## ampersand
                                    gsub("&amp;", "&");

                                    ## double quotation mark
                                    gsub("&quot;", "\"");

                                    ## single quotation mark
                                    gsub("&apos;", "\u0027");

                                    ## cent
                                    gsub("&cent;", "¢");

                                    ## pound
                                    gsub("&pound;", "£");

                                    ## yen
                                    gsub("&yen;", "¥");

                                    ## euro
                                    gsub("&euro;", "€");

                                    ## copyright
                                    gsub("&copy;", "©");

                                    ## registered trademark
                                    gsub("&reg;", "®");

                                    ## trademark
                                    gsub("&trade;", "™");

                                    print $0;
                                }' <<< "${curl_output}"
                           )

    # reverse output
    \tac <<< "${filtered_output}"

    if [[ "${no_results}" == "true" ]]
    then
        \echo -e "\e[01;31mNo results!\e[0m" >&2
        \return 1
    fi
}

## navigate to the real path of symlinks, which point to directories or files
cdl()
{
    local symlink_file="${1}"
    local argument_count="${#argv}"
    local resolved_path
    local file_resolved_path

    if [[ "${argument_count}" == "1" ]]
    then
        # check, if symlink is a directory
        resolved_path=$(\realpath "${symlink_file}")

        if [[ -d "${resolved_path}" ]]
        then
            \cd "${resolved_path}"
        else
            # if not, cut off the filename
            file_resolved_path="${resolved_path%/*}"
            \echo "Correcting '${resolved_path}' to: '${file_resolved_path}'." >&2
            \cd "${file_resolved_path}"
        fi
    else
        echo -e "\e[01;31mOne argument required!\e[0m" >&2
        return 1
    fi
}

## create directories and navigate to the last one
cdk()
{
    local directory_path="${*}"

    \mkdir --parents "${directory_path}"

    \echo "Changing directory to: '${directory_path}'."
    \cd "${directory_path}"
}

## calculate in a convenient way
calc()
{
    local input="${*}"

    # delimit output with thousand separators
    \gawk 'BEGIN{ printf("%\047f", '"${input}"') }'
}

## generate and check file checksums via "blake2" in parallel
gsum()
{
    local checksum_file="./checksums.b2"
    local available_processors=$(\nproc --all)
    local xargs_max_args="1"
    local overwrite_checksum_file
    declare -a file_array

    if [[ -f "${checksum_file}" ]]
    then
        \read $'overwrite_checksum_file?\e[01;31mThe file: '"'${checksum_file}'"$' already exists. Do you really want to overwrite it? (y/N): \e[0m' >&2
        if [[ "${overwrite_checksum_file:-n}" =~ [nN] ]]
        then
            \return 1
        fi
    fi

    \find \
        "." \
        -type f \
        -not \
        -name "${checksum_file##*/}" \
        -print0 \
        | \xargs \
            --null \
            --no-run-if-empty \
            --max-procs="${available_processors}" \
            --max-args="${xargs_max_args}" \
            \b2sum > "${checksum_file}"
}
csum()
{
    local checksum_file="./checksums.b2"
    local available_processors=$(\nproc --all)

    if [[ ! -f "${checksum_file}" ]]
    then
        \echo -e "\e[01;31mThe file: '${checksum_file}' could not be found or is not a file.\e[0m" >&2
        \return 1
    fi

    # the parameter "--replace" and a subshell ("sh") must be used here, in
    # order to check files in parallel and to be compatible with "b2sum --check",
    # since the parameter "--zero" and "--check" are mutually exclusive.
    # example command:
    # $ b2sum --check --quiet <<< "<some_checksum>  <some_filename>"
    \xargs \
        --no-run-if-empty \
        --arg-file="${checksum_file}" \
        --max-procs="${available_processors}" \
        --replace="{}" \
        \sh -c \
            "\b2sum --check --quiet <<< '{}'" _
}

## set up "binfmt" for "qemu"
### derived from: https://github.com/qemu/qemu/blob/master/scripts/qemu-binfmt-conf.sh
### see also: https://www.kernel.org/doc/Documentation/admin-guide/binfmt-misc.rst
binfmt_qemu()
{
    local function_name="${0}"
    local cpu_arch_switch="${1:-aarch64}"
    local enable_switch="${2:-enable}"
    local binfmt_directory="/proc/sys/fs/binfmt_misc"
    local binfmt_register_file="${binfmt_directory}/register"
    local binfmt_qemu_cpu_file="${binfmt_directory}/qemu-${cpu_arch_switch}"
    local binfmt_status_file="${binfmt_directory}/status"

    if [[ "${EUID}" != "0" ]]
    then
        \echo -e "\e[01;31mThis function must be executed with root privileges!\e[0m" >&2
        \return 1
    elif [[ ! -d "${binfmt_directory}" ]]
    then
        \echo -e "\e[01;31mCould not find directory: '${binfmt_directory}' or is not a directory.\e[0m" >&2
        \return 1
    elif [[ ! -f "${binfmt_register_file}" ]]
    then
        \echo -e "\e[01;31mCould not find file: '${binfmt_register_file}' or is not a file.\e[0m" >&2
        \return 1
    elif [[ ! -f "${binfmt_status_file}" ]]
    then
        \echo -e "\e[01;31mCould not find file: '${binfmt_status_file}' or is not a file.\e[0m" >&2
        \return 1
    fi

    # backslashes need to be escaped!
    case "${cpu_arch_switch}" in
        "aarch64")
            local magic='\\x7fELF\\x02\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\xb7\\x00'
            local mask='\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff\\xff'
            local cpu_arch="aarch64"
            ;;

        "arm")
            local magic='\\x7fELF\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x28\\x00'
            local mask='\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff\\xff'
            local cpu_arch="arm"
            ;;

        "status")
            \echo -e "\e[01;34mContent of directory: '${binfmt_directory}':\e[0m"
            \ls "${binfmt_directory}"

            \echo -e "\n\e[01;34mStatus of '${binfmt_status_file}':\e[0m"
            \cat "${binfmt_status_file}"

            \return 0
            ;;

        "disable-all")
            \echo "-1" > "${binfmt_status_file}"
            "${function_name}" status

            \return 0
            ;;


        "help")
            \echo "Usage: ${function_name} [aarch64 | arm | help | status | disable-all] [enable | disable | help]"
            \echo "Default parameters: aarch64 enable"
            \return 0
            ;;

        *)
            \echo -e "\e[01;31mWrong first parameter: '${cpu_arch_switch}'.\e[0m" >&2
            "${function_name}" help
            \return 1
    esac

    case "${enable_switch}" in
        "enable")
            if [[ -f "${binfmt_qemu_cpu_file}" ]]
            then
                \echo -e "\e[01;31mFile: '${binfmt_qemu_cpu_file}' already exists!\e[0m" >&2
                "${function_name}" status
                \return 1
            else
                local interpreter="/usr/bin/qemu-${cpu_arch}-static"

                \echo ":qemu-${cpu_arch}:M::${magic}:${mask}:${interpreter}:" > "${binfmt_register_file}"

                if [[ ! -f "${binfmt_qemu_cpu_file}" ]]
                then
                    \echo -e "\e[01;31mSomething went wrong creating the file: '${binfmt_qemu_cpu_file}'.\e[0m" >&2
                    "${function_name}" status
                    \return 1
                else
                    \cat "${binfmt_qemu_cpu_file}"
                    \echo ""
                    "${function_name}" status
                fi
            fi
            ;;

        "disable")
            if [[ ! -f "${binfmt_qemu_cpu_file}" ]]
            then
                \echo -e "\e[01;31mCould not find file: '${binfmt_qemu_cpu_file}' or is not a file.\e[0m" >&2
                "${function_name}" status
                \return 1
            else
                \echo "-1" > "${binfmt_qemu_cpu_file}"
                "${function_name}" status
            fi
            ;;

        "help")
            "${function_name}" help
            ;;

        *)
            \echo -e "\e[01;31mWrong second parameter: '${enable_switch}'.\e[0m" >&2
            "${function_name}" help
            \return 1
    esac
}
## prepare and "unprepare" a chroot environment conveniently
pchroot()
{
    if [[ "${EUID}" == "0" ]]
    then
        declare -a system_directory_array
        system_directory_array=("/proc/" "/sys/" "/dev/")
        local system_directory
        declare -a chroot_directory_array
        chroot_directory_array=("./proc/" "./sys/" "./dev/")
        local chroot_directory

        for system_directory in "${system_directory_array[@]}"
        do
            if [[ ! -d "${system_directory}" ]]
            then
                \echo -e "\e[01;31mThe system directory: '${system_directory}' could not be found or is not a directory.\e[0m" >&2
                \return 1
            fi
        done

        for chroot_directory in "${chroot_directory_array[@]}"
        do
            if [[ ! -d "${chroot_directory}" ]]
            then
                \echo -e "\e[01;31mThe chroot directory: '${chroot_directory}' could not be found or is not a directory.\e[0m" >&2
                \return 1
            fi
        done

        \mount --verbose --types proc "${system_directory_array[1]}" "${chroot_directory_array[1]}"
        \mount --verbose --rbind "${system_directory_array[2]}" "${chroot_directory_array[2]}"
        \mount --verbose --make-rslave "${chroot_directory_array[2]}"
        \mount --verbose --rbind "${system_directory_array[3]}" "${chroot_directory_array[3]}"
        \mount --verbose --make-rslave "${chroot_directory_array[3]}"

        \echo -e "\e[01;33mPrepared the chroot environment.\e[0m\n" >&2
        \echo -e "\e[01;33mExecute the following command to enter it:\e[37m chroot . \"/bin/bash\"\e[0m" >&2
        \echo -e "\e[01;33mIf the CPU architectures differ, the binary \"qemu-<arch>-static\" may be used:\e[37m cp \"qemu-<arch>-static\" \"usr/bin/\" && chroot . qemu-<arch>-static \"/bin/bash\"\e[0m" >&2
        \echo -e "\e[01;33mAlso make sure to set the magic and mask bytes for QEMU:\e[37m binfmt_qemu\e[0m" >&2
        \echo -e "\e[01;33mExecute the following command to prepare the environment within the chroot:\e[37m source \"/etc/profile\" && export PS1=\"(chroot) \${PS1}\"\e[0m" >&2
    else
        \echo -e "\e[01;31mEntering a chroot environment requires root privileges!\e[0m" >&2
        \return 1
    fi
}
uchroot()
{
    if [[ "${EUID}" == "0" ]]
    then
        declare -a chroot_directory_array
        chroot_directory_array=("./proc/" "./sys/" "./dev/" "./boot")
        local chroot_directory

        for chroot_directory in "${chroot_directory_array[@]}"
        do
            if [[ ! -d "${chroot_directory}" ]]
            then
                \echo -e "\e[01;31mThe chroot directory: '${chroot_directory}' could not be found or is not a directory.\e[0m" >&2
                \return 1
            elif ! \mountpoint --quiet "${chroot_directory}"
            then
                \echo -e "\e[01;31mThe chroot directory: '${chroot_directory}' is not mounted.\e[0m" >&2
            fi
        done

        \umount --verbose --lazy --recursive ${chroot_directory_array[@]}

        \echo -e "\e[01;33mUnprepared the chroot environment.\e[0m" >&2
    else
        \echo -e "\e[01;31mUnpreparing a chroot environment requires root privileges!\e[0m" >&2
        \return 1
    fi
}

## toggle extended globbing
extended_glob_on()
{
    setopt extended_glob
    \echo -e "\e[01;33mExtended globbing syntax has been activated!\e[0m"
    \echo "Examples:"
    \echo "Remove all files, except the file 'nom': rm -- ^\"nom\""
    \echo "Remove all files, except files with the suffix 'png' and 'jpg': rm -- ^.*(png|jpg)"
}
extended_glob_off()
{
    \unsetopt extended_glob
    \echo -e "\e[01;33mExtended globbing has been deactivated!\e[0m"
}

## be able to use "gpg", when connected via "ssh"
gpg_ssh_init()
{
    if [[ "${EUID}" != "0" ]]
    then
        if [[ "${SSH_TTY}" != "" ]]
        then
            # "killall --ns" to kill multiple pids does not work.
            \killall $(\find "/usr/bin" -type f -name "pinentry*" -printf "%P ") >/dev/null 2>&1
            \export PINENTRY_USER_DATA="\pinentry-curses"

            # see "man 1 gpg-agent"
            \unset SSH_AGENT_PID
            if [[ "${gnupg_SSH_AUTH_SOCK_by:-0}" != "${$}" ]]
            then
                \export SSH_AUTH_SOCK="$(\gpgconf --list-dirs agent-ssh-socket)"
            fi

            # exporting the environment variable "GPG_TTY" must be done manually,
            # otherwise the scroll buffer and the input of "tmux" is messed up and unusuable.
            \echo -e "\e[01;33mExport the environment variable 'GPG_TTY' with the current 'PTS' ('${SSH_TTY}') in order to use 'gpg' in a pseudo terminal: export GPG_TTY=\"\$(tty)\"\e[0m" >&2
        else
            \echo -e "\e[01;31mThe environment variable 'SSH_TTY' is not set: '${SSH_TTY}'.\e[0m" >&2
            \return 1
        fi
    else
        \echo -e "\e[01;31mThis function must be executed as non-privileged user!\e[0m" >&2
        \return 1
    fi
}

## print invoice files in chronological descending order
lpr_invoice()
{
    local directory_file_list=$(\ls -1tr)
    local directory_file
    declare -a invoice_file_array
    local print_files
    local invoice_index_number="1"
    local invoice_index_prefix
    local invoice_page_count

    if [[ "${directory_file_list}" != "" ]]
    then
        \echo ""
        while \read -r directory_file
        do
            if [[ -f "${directory_file}" ]]
            then
                if (( "${invoice_index_number}" < 10 ))
                then
                    invoice_index_prefix="0"
                else
                    \unset invoice_index_prefix
                fi

                invoice_page_count=$(
                                        \pdfinfo "${directory_file}" 2>&1 \
                                            | \gawk '/Pages:/ { print $2 }'
                                    )

                if (( invoice_page_count > 9 ))
                then
                    invoice_page_count="\e[01;31m${invoice_page_count}\e[0m"
                elif (( invoice_page_count > 4 ))
                then
                    invoice_page_count="\e[01;33m${invoice_page_count}\e[0m"
                fi

                invoice_file_array+=("${directory_file}")
                if (( invoice_index_number % 2 == 0 ))
                then
                    \echo -e "   \e[01;34m${invoice_index_prefix}${invoice_index_number} (Pages: ${invoice_page_count}\e[01;34m):\t${directory_file}\e[0m"
                else
                    \echo -e "   \e[01;37m${invoice_index_prefix}${invoice_index_number} (Pages: ${invoice_page_count}\e[01;37m):\t${directory_file}\e[0m"
                fi
                (( invoice_index_number++ ))
            fi
        done <<< "${directory_file_list}"

        if [[ "${invoice_file_array[@]}" != "" ]]
        then
            \read $'print_files?\n\e[01;31mDo you really want to print the above files in chronologically descending order? (y/N): \e[0m' >&2

            case "${print_files:-n}" in
                "y"|"Y")
                    \lpr "${invoice_file_array[@]}"
                    \echo -e "\n\e[01;33mDo not forget to sort the printed files chronologically!\e[0m" >&2
                    \echo -e "\e[01;33mDo not forget to sort the printed files chronologically!\e[0m" >&2
                    \echo -e "\e[01;33mDo not forget to sort the printed files chronologically!\e[0m\n" >&2
                    ;;

                "n"|"N")
                    \return 1
                    ;;

                *)
                    \echo -e "\e[01;31mWrong input: '${print_files}'.\e[0m" >&2
                    \return 1
            esac
        else
            \echo -e "\e[01;31mThe invoice file array: '${invoice_file_array[@]}' is empty. Nothing to do...\e[0m" >&2
            \return 1
        fi
    else
        \echo -e "\e[01;31mThe directory file list: '${directory_file_list}' is empty. Nothing to do...\e[0m" >&2
        \return 1
    fi
}

## generate strong passwords with ~130 bit entropy
genpw()
{
    local function_name="${0}"
    local -i password_length=24
    local remove_characters="[:space:]"
    local -i password_counter
    local -i password_count=20
    local password_output
    local password_entropy
    local entropy_result
    local lowercase_letter_regex="[a-z]"
    local lowercase_letter_amount="26"
    local uppercase_letter_regex="[A-Z]"
    local uppercase_letter_amount="26"
    local numeric_regex="[0-9]"
    local numeric_amount="10"
    local ascii_character_string="[[:punct:]]"
    local ascii_character_amount="32"

    while (( ${#} ))
    do
        case "${1}" in
            "-a" | "--no-lowercase")
                remove_characters+="a-z"
                ;;

            "-A" | "--no-uppercase")
                remove_characters+="A-Z"
                ;;

            "-c" | "--count")
                password_count="${2}"
                shift
                ;;

            "-l" | "--length")
                password_length="${2}"
                shift
                ;;

            "-n" | "--no-numbers")
                remove_characters+="0-9"
                ;;

            "-s" | "--no-special")
                remove_characters+="[:punct:]"
                ;;

            "-h" | "--help")
                \echo ""
                \echo "Usage: ${function_name} [options]... <arguments>..."
                \echo ""
                \echo "OPTIONS:"
                \echo "  -a, --no-lowercase              exclude lowercase characters"
                \echo "  -A, --no-uppercase              excluce uppercase characters"
                \echo "  -c, --count <number>            define the amount of generated passwords"
                \echo "  -l, --length <number>           define password length"
                \echo "  -n, --no-numbers                exclude numeric characters"
                \echo "  -s, --no-special                exclude special characters"
                \echo "  -h, --help                      show this message"
                \echo ""
                \echo "EXAMPLES:"
                \echo "  generate a password with 24 characters"
                \echo "      ${function_name} --length 24"
                \echo ""
                \echo "  exclude special and uppercase characters"
                \echo "      ${function_name} --no-special --no-uppercase"
                \return 0
        esac
        \shift 1 >/dev/null 2>&1 || \break
    done

    for password_counter in {1..${password_count}}
    do
        password_entropy="0"
        password_output=$(
                            \strings \
                                --bytes="1" \
                                "/dev/urandom" \
                                | \tr \
                                    --delete \
                                    "${remove_characters}" \
                                    | \head \
                                        --bytes="${password_length}"
                         )

        if [[ "${password_output}" =~ "${lowercase_letter_regex}" ]]
        then
            # add 26
            (( password_entropy+=lowercase_letter_amount ))
        fi
        if [[ "${password_output}" =~ "${uppercase_letter_regex}" ]]
        then
            # add 26
            (( password_entropy+=uppercase_letter_amount ))
        fi
        if [[ "${password_output}" =~ "${numeric_regex}" ]]
        then
            # add 10
            (( password_entropy+=numeric_amount ))
        fi
        if [[ "${password_output}" =~ "${ascii_character_string}" ]]
        then
            # add 32
            (( password_entropy+=ascii_character_amount ))
        fi

        entropy_result=$(
                            \gawk \
                                --assign="password_entropy=${password_entropy}" \
                                '{
                                    printf "%.4f", log(password_entropy^$0)/log(2);
                                 }' <<< "${password_length}"
                        )

        \printf "%s    %s bit (%s)\n" "${password_output}" "${entropy_result}" "${password_entropy}"
    done
}

## determine last portage synchronisation
getLastPortageSync()
{
    local portage_timestamp_file="/var/db/repos/gentoo/metadata/timestamp.chk"

    if [[ ! -f "${portage_timestamp_file}" ]]
    then
        \echo -e "\e[01;31mThe file: '${portage_timestamp_file}' could not be found or is not a file.\e[0m" >&2
        \return 1
    else
        local current_unix_time=$(\date +%s)
        local portage_unix_time=$(\date --date="$(< ${portage_timestamp_file})" +%s)
        local days_since_last_sync=$(( (${current_unix_time} - ${portage_unix_time}) / 86400.0 ))
    fi

    if (( ${days_since_last_sync} >= 7.5 && ${days_since_last_sync} < 20 ))
    then
        \printf "\e[01;33m[%.2f] days since last portage synchronisation.\e[0m\n" "${days_since_last_sync}"
    elif (( ${days_since_last_sync} >= 20 ))
    then
        \printf "\e[01;31;5m[%.2f] days since last portage synchronisation!\e[0m \e[01;31m(execute as root: /root/bin/update.sh)\e[0m\n" "${days_since_last_sync}"
    elif [[ "${1}" == "--verbose" ]]
    then
        \printf "\e[01;34m[%.2f] days since last portage synchronisation.\e[0m\n" "${days_since_last_sync}"
    fi
}

## list all process signals
lsig()
{
    \cat <<- LSIG_EOF
		 Signal             Standard    Action      Comment
		 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────
		 1: SIGHUP          P1990       Term        Hangup detected on controlling terminal or death of controlling process
		 2: SIGINT          P1990       Term        Interrupt from keyboard
		 3: SIGQUIT         P1990       Core        Quit from keyboard
		 4: SIGKILL         P1990       Term        Kill signal
		 5: SIGTRAP         P2001       Core        Trace/breakpoint trap
		 6: SIGABRT         P1990       Core        Abort signal from abort(3)
		 7: SIGBUS          P2001       Core        Bus error (bad memory access)
		 8: SIGFPE          P1990       Core        Floating-point exception
		 9: SIGKILL         P1990       Core        Illegal Instruction
		10: SIGUSR1         P1990       Term        User-defined signal 1
		11: SIGSEGV         P1990       Core        Invalid memory reference
		12: SIGUSR2         P1990       Term        User-defined signal 2
		13: SIGPIPE         P1990       Term        Broken pipe: write to pipe with no readers; see pipe(7)
		14: SIGALRM         P1990       Term        Timer signal from alarm(2)
		15: SIGTERM         P1990       Term        Termination signal
		16: SIGSTKFLT         -         Term        Stack fault on coprocessor (unused)
		17: SIGCHLD         P1990       Ign         Child stopped or terminated
		18: SIGCONT         P1990       Cont        Continue if stopped
		19: SIGSTOP         P1990       Stop        Stop process
		20: SIGTSTP         P1990       Stop        Stop typed at terminal
		21: SIGTTIN         P1990       Stop        Terminal input for background process
		22: SIGTTOU         P1990       Stop        Terminal output for background process
		23: SIGURG          P2001       Ign         Urgent condition on socket (4.2BSD)
		24: SIGXCPU         P2001       Core        CPU time limit exceeded (4.2BSD); see strlimit(2)
		25: SIGXFSZ         P2001       Core        File size limit exceeded (4.2BSD); see strlimit(2)
		26: SIGVTALRM       P2001       Term        Virtual alarm clock (4.2BSD)
		27: SIGPROF         P2001       Term        Profiling timer expired
		28: SIGWINCH          -         Ign         Window resize signal (4.3BSD, Sun)
		29: SIGIO             -         Term        I/O now possible (4.2BSD)
		30: SIGPWR            -         Term        Power failure (System V)
		31: SIGSYS          P2001       Core        Bad system call (SVr4); see also seccomp(2)
		32: Not defined       -          -          -
		33: Not defined       -          -          -
		34: SIGRTMIN        P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
		35: SIGRTMIN+1      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
		36: SIGRTMIN+2      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
		37: SIGRTMIN+3      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
		38: SIGRTMIN+4      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
		39: SIGRTMIN+5      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
		40: SIGRTMIN+6      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
		41: SIGRTMIN+7      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
		42: SIGRTMIN+8      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
		43: SIGRTMIN+9      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
		44: SIGRTMIN+10     P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
		45: SIGRTMIN+11     P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
		46: SIGRTMIN+12     P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
		47: SIGRTMIN+13     P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
		48: SIGRTMIN+14     P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
		49: SIGRTMIN+15     P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
		50: SIGRTMAX-14     P2001       (Term)      Real-time signal max
		51: SIGRTMAX-13     P2001       (Term)      Real-time signal max
		52: SIGRTMAX-12     P2001       (Term)      Real-time signal max
		53: SIGRTMAX-11     P2001       (Term)      Real-time signal max
		54: SIGRTMAX-10     P2001       (Term)      Real-time signal max
		55: SIGRTMAX-9      P2001       (Term)      Real-time signal max
		56: SIGRTMAX-8      P2001       (Term)      Real-time signal max
		57: SIGRTMAX-7      P2001       (Term)      Real-time signal max
		58: SIGRTMAX-6      P2001       (Term)      Real-time signal max
		59: SIGRTMAX-5      P2001       (Term)      Real-time signal max
		60: SIGRTMAX-4      P2001       (Term)      Real-time signal max
		61: SIGRTMAX-3      P2001       (Term)      Real-time signal max
		62: SIGRTMAX-2      P2001       (Term)      Real-time signal max
		63: SIGRTMAX-1      P2001       (Term)      Real-time signal max
		64: SIGRTMAX        P2001       (Term)      Real-time signal max
		
		The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.
		
		Up to and including Linux 2.2, the default behavior for SIGSYS, SIGXCPU, SIGXFSZ, and (on architectures other
		than SPARC and MIPS) SIGBUS was to terminate the process (without a core dump).  (On some other UNIX  systems
		the  default action for SIGXCPU and SIGXFSZ is to terminate the process without a core dump.)  Linux 2.4 con‐
		forms to the POSIX.1-2001 requirements for these signals, terminating the process with a core dump.
		
		SIGEMT is not specified in POSIX.1-2001, but nevertheless appears on most other UNIX systems, where  its  de‐
		fault action is typically to terminate the process with a core dump.
		
		SIGPWR  (which  is not specified in POSIX.1-2001) is typically ignored by default on those other UNIX systems
		where it appears.
		
		SIGIO (which is not specified in POSIX.1-2001) is ignored by default on several other UNIX systems.
		
		See also: man 7 signal
	LSIG_EOF
}

## monitor a single running process
pmon()
{
    local process_name="${1}"
    local watch_interval="${2:-0.1}"
    local process_name_last_character="${process_name:(-1)}"
    # regex trick, in order to not match itself
    local search_string="${process_name/%${process_name_last_character}/[${process_name_last_character}]}"

    # use the command "\watch" and "\ps",
    # in order to use them as unaliased commands.
    # the command "unalias" could be used here, but once executed,
    # this would affect the current shell.
    \watch --differences --precise --interval="${watch_interval}" \
        "\gawk --assign=search_string="${search_string}" \
            'NR == 1; \$0 ~ search_string' < <(\ps faux)"
}

## follow one or multiple running process
fpid()
{
    declare -a process_array
    process_array=("${@}")
    local process
    declare -a process_id_array
    local process_id
    local first_process_id
    local process_name
    local process_real_name
    declare -A process_name_id_array
    local tail_pid_parameter

    if [[ "${process_array[@]}" == "" ]]
    then
        \echo -e "\e[01;31mCould not find any process IDs for: '${process_array[@]}'.\e[0m" >&2
        \return 1
    fi

    for process in "${process_array[@]}"
    do
        # handle process ids
        if [[ "${process}" =~ "^[0-9]+$" ]]
        then
            process_id="${process}"
            if [[ ! -d "/proc/${process_id}/" ]]
            then
                \echo -e "\e[01;33mCould not find process ID: '${process_id}'. Skipping...\e[0m\n" >&2
                \continue
            fi

            process_real_name=$(
                                \gawk \
                                    '/Name:/ { $1=""; print substr($0, 2) }' \
                                    "/proc/${process_id}/status"
                               )
            process_name_id_array[${process_real_name}]+="${process_id},"
            tail_pid_parameter+="--pid=${process_id} "
        # handle process names
        else
            process_name="${process}"
            # get first process id from process name
            if ! process_id_array=($(\pgrep "${process_name}"))
            then
                \echo -e "\e[01;33mCould not find process name: '${process_name}'. Skipping...\e[0m\n" >&2
                \continue
            fi
            # "zsh"'s array index starts at "1"
            first_process_id="${process_id_array[1]}"
            # get real process name from "procfs"
            # remove leading space via "substr()"
            process_real_name=$(
                                \gawk \
                                    '/Name:/ { $1=""; print substr($0, 2) }' \
                                    "/proc/${process_id_array[1]}/status"
                               )
            process_name_id_array[${process_real_name}]+="${first_process_id},"
            tail_pid_parameter+="--pid=${first_process_id} "
        fi
    done

    \echo -e "\e[01;34mWaiting for the following processes to exit:\e[0m"
    process_name=
    process_id=
    for process_name process_id in "${(@kv)process_name_id_array[@]}"
    do
        # remove trailing comma here
        \echo -e "\e[01;35m${process_name}: \e[01;37m${process_id%,}\e[0m"
    done

    if [[ "${(@z)tail_pid_parameter% }" == "" ]]
    then
        \echo -e "\e[01;31mTail PID parameter array is empty. Exiting...\e[0m\n" >&2
        \return 1
    fi
    # delimit the pid parameters via space character and remove the
    # trailing space character
    \tail --follow="descriptor" "/dev/null" "${(@z)tail_pid_parameter% }"
    \echo -e "\e[01;33mAbove processes exited...\e[0m" >&2

    \return 0
}

## notify after a command has finished
## usage: notifyme <some_command>
notifyme()
{
    local -i start_time="$(\date +%s)"

    "${@}"

    local end_time="$(\date +%s)"
    local total_execution_time="$(( end_time - start_time ))"
    #if (( total_execution_time >= 15 ))
    #then
        \notify-send \
            --app-name="Notification" \
            --icon="notifications" \
            --urgency="critical" \
            "Command finished [${total_execution_time} seconds]" \
            "'$(\echo ${@})'"
    #fi
}

## list real and effective user and group ids in a more convenient way
listids()
{
    declare -a username_array
    username_array=("${@:-${USER}}")
    local username
    declare -A username_id_array
    local username_id
    local id_name_list

    # fill associative array
    for username in "${username_array[@]}"
    do
        id_name_list=$(\id "${username}")

        if [[ "${id_name_list}" == "" ]]
        then
            \continue
        else
            username_id_array[${username}]="${id_name_list}"
        fi
    done

    # output associative array
    for username_id in ${(k)username_id_array}
    do
        \echo -e "\e[01;34mIDs of the user '\e[01;33m${username_id}\e[0m\e[01;34m':\e[0m"
        \gawk \
            --field-separator ',' \
            '{
                gsub("[, ]", "\n    ");
                sub("^", "    ");
                print $0"\n"
             }' <<< ${username_id_array[${username_id}]}
    done
}

## list loop devices and their modification timestamps
lost()
{
    \losetup --list
    \echo -e "\n\e[01;34mModification timestamps (chronological descending order):\e[0m"
    \stat --format="%n: %y" $(\losetup --raw | \gawk 'NR >= 2 { print $1 }') \
        | \sort --reverse --numeric-sort --key="3"
}

## bash: execute bell when command is finished
precmd()
{
    \eval "${PROMPT_COMMAND}"
}
PROMPT_COMMAND+='tput bel;'

## dynamically change the window title for terminals
if [[ "${TERM}" != "" && "${TERM}" == "st"* || "${TERM}" == "alacritty" ]]
then
    precmd()
    {
        # output on which level (%L) this shell is running on.
        # append the current directory (%~), substitute home directories with a tilde.
        # "\a" bell (man 1 \echo)
        # "print" must be used here; \echo cannot handle prompt expansions (%L)
        \print -Pn "\e]0;${USER}@${HOSTNAME}: zsh[%L] %~\a"
    }

    preexec()
    {
        # output current executed command with parameters
        \echo -en "\e]0;${USER}@${HOSTNAME}: ${1}\a"
    }
fi


## list access, owner and group permission tree for the current or defined working directory
ptree()
{
    local directory_path="${1:-$(\pwd)}"
    \namei --long --mountpoints "${directory_path}"
}

## list processes in a tree structure
pst()
{
    \pstree \
        --unicode \
        --arguments \
        --highlight-all \
        --show-pids \
        --show-pgids \
        --numeric-sort \
        --color='age'

    \echo -e "\n\e[01;32mProcesses newer   than 60 seconds (<=60s) are green.\e[0m"
    \echo -e "\e[01;33mProcesses newer   than an hour    (<=1h)  are yellow.\e[0m"
    \echo -e "\e[01;31mProcesses older   than an hour    (>1h)   are red.\e[0m"
}

pss()
{
    # can also be a process name
    local process_id="${1}"
    local process_list=$(\ps -axo user,group,uid,gid,ppid,pid,pgid,sid,sgid,%cpu,%mem,vsz,rss,tty,stat,start,time,comm,args="ARGS")

    if [[ "${process_id}" != "" ]]
    then
        # filter by process id and show the header
        \gawk \
            --assign="process_id=${process_id}" \
            'NR == 1;
             $0 ~ process_id' <<< "${process_list}"
    else
        \echo "${process_list}"
    fi
}

## upload files to "transfer.sh"
transfer()
{
    local file
    declare -a file_array
    file_array=("${@}")

    if [[ "${file_array[@]}" == "" || "${1}" == "--help" || "${1}" == "-h" ]]
    then
        \echo "${0} - Upload arbitrary files to \"transfer.sh\"."
        \echo ""
        \echo "Usage: ${0} [options] [<file>]..."
        \echo ""
        \echo "OPTIONS:"
        \echo "  -h, --help"
        \echo "      show this message"
        \echo ""
        \echo "EXAMPLES:"
        \echo "  Upload a single file from the current working directory:"
        \echo "      ${0} \"image1.img\""
        \echo ""
        \echo "  Upload multiple files from the current working directory:"
        \echo "      ${0} \"image1.img\" \"image2.img\""
        \echo ""
        \echo "  Upload multiple files with spaces in their filename from the current working directory:"
        \echo "      ${0} \"image 1.img\" image\ 2.img"
        \echo ""
        \echo "  Upload a file from a different directory:"
        \echo "      ${0} \"/tmp/image1.img\""
        \echo ""
        \echo "  Upload multiple files from a different directory:"
        \echo "      ${0} transfer /tmp/{image1.img,image\ 1.img,\"image 2.img\"}"
        \echo ""
        \echo "  Upload all files from the current working directory. Be aware of the webserver's rate limiting!:"
        \echo "      ${0} *"
        \echo ""
        \echo "  Upload a single file from the current working directory and filter out the delete token and download link:"
        \echo "      ${0} \"image.img\" | gawk --field-separator=\": \" '/Delete token:/ { print \$2 } /Download link:/ { print \$2 }'"
        \echo ""
        \echo "  Show help text from \"transfer.sh\":"
        \echo "      curl --request GET --url \"https://transfer.sh\""
        \return 0
    else
        for file in "${file_array[@]}"
        do
            if [[ ! -f "${file}" ]]
            then
                \echo -e "\e[01;31mThe file: '${file}' could not be found or is not a file.\e[0m" >&2
                \return 1
            fi
        done
        \unset file
    fi

    local upload_files
    local curl_output
    local gawk_output
    local url_filename

    # use short parameters here to be compatible with bsd, macos and linux
    # long parameters: --total --block-size="K" --dereference
    \du -ckL "${file_array[@]}" >&2

    # be compatible with "bash"
    if [[ "${ZSH_NAME}" == "zsh" ]]
    then
        \read $'upload_files?\e[01;31mDo you really want to upload the above files ('"${#file_array[@]}"$') to "transfer.sh"? (y/N): \e[0m' >&2
    elif [[ "${BASH}" == *"bash"* ]]
    then
        \read -p $'\e[01;31mDo you really want to upload the above files ('"${#file_array[@]}"$') to "transfer.sh"? (y/N): \e[0m' upload_files >&2
    fi

    case "${upload_files:-n}" in
        "y"|"Y")
            # for the sake of the progress bar, execute "curl" for each file.
            # the parameters "--include" and "--form" will suppress the progress bar.
            for file in "${file_array[@]}"
            do
                url_filename="${file##*/}"
                url_filename="${url_filename// /%20}"
                # show delete link and filter out the delete token from the response header after upload.
                # it is important to save "curl's" "stdout" via a subshell to a variable or redirect it to another command,
                # which just redirects to "stdout" in order to have a sane output afterwards.
                # the progress bar is redirected to "stderr" and is only displayed,
                # if "stdout" is redirected to something; e.g. ">/dev/null", "tee /dev/null" or "| <some_command>".
                # the response header is redirected to "stdout", so redirecting "stdout" to "/dev/null" does not make any sense.
                # redirecting "curl's" "stderr" to "stdout" ("2>&1") will suppress the progress bar.
                curl_output=$(
                                \curl \
                                    --request PUT \
                                    --progress-bar \
                                    --dump-header - \
                                    --upload-file "${file}" \
                                    --url "https://transfer.sh/${url_filename}"
                             )
                gawk_output=$(
                                \gawk \
                                    'gsub("\r", "", $0) && tolower($1) ~ /x-url-delete/
                                    {
                                        delete_link=$2;
                                        print "Delete command: curl --request DELETE " --url "\""delete_link"\"";

                                        delete_token=gensub(".*/", "", "g", delete_link);
                                        print "Delete token: " delete_token;
                                    }

                                    END{
                                        print "Download link: " $0;
                                    }' <<< "${curl_output}" \
                             )

                # return the results via "stdout", "gawk" does not do this for some reason.
                \echo -e "${gawk_output}\n"

                # avoid rate limiting as much as possible; nginx: too many requests.
                if (( ${#file_array[@]} > 4 ))
                then
                    \sleep 5
                fi
            done
            ;;

        "n"|"N")
            \return 1
            ;;

        *)
            \echo -e "\e[01;31mWrong input: '${upload_files}'.\e[0m" >&2
            \return 1
    esac
}

## add timestamp for each input; mimics "ts" from "moreutils"
ts()
{
    \gawk \
        '{
            print strftime("[%Y-%m-%dT%H:%M:%S%z]:"), $0;
            fflush(stdout);
         }'
}

## information, which seems to be volatile for my brain
thingsIalwaysForget()
{
    \echo -e "\e[01;34miproute2:\e[0m"
    \echo "  Configure a static IP address:"
    \echo "      ip address add <local_ip_address>/<cidr_subnet_mask> dev <inferface>"
    \echo ""
    \echo "  Configure a default gateway:"
    \echo "      ip route add default via <default_gateway> dev <interface>"
    \echo ""
    \echo -e "\e[01;34mTranslations:\e[0m"
    \echo "  None."
    \echo ""
    \echo -e "\e[01;34mPortage:\e[0m"
    \echo "  Downgrading a package:"
    \echo "      emerge --oneshot \=<package_name>-<major_version>.<minor_version>.<patch_version>"
    \echo "      emerge --oneshot \=<package_name>:<major_version>.<minor_version>.<patch_version>"
    \echo ""
    \echo -e "\e[01;34mHTML:\e[0m"
    \echo "  Collapsible details:"
    \echo "      <details><summary>Expand</summary><p>"
    \echo ""
    \echo "          ### Heading"
    \echo "          Text"
    \echo "      </details></p>"
}

## get current wan ip address
wan()
{
    declare -a ip_version_array
    ip_version_array=("ipv4" "ipv6")
    local ip_version

    for ip_version in "${ip_version_array[@]}"
    do
        \echo -n "${ip_version}: "
        \curl \
            --request GET \
            --silent \
            --show-error \
            --"${ip_version}" \
            --url "https://ifconfig.co/"
    done
}

## get weather forecast information
weather()
{
    local input_string="${*// /+}"

    if [[ "${input_string}" == "--help" || "${input_string}" == "-h" ]]
    then
        input_string=":help"
    fi

    \curl \
        --request GET \
        --silent \
        --show-error \
        --url "https://wttr.in/${input_string}"
}

## output the paths to binary files from "${PATH}" and functions of the current shell
wherefrom()
{
    declare -a binary_name_array
    binary_name_array=("${@}")
    local binary_name_command
    local binary_name which
    local binary_name_whereis
    local binary_name_type

    #unalias "${binary_name_array[@]}" 2>/dev/null

    \echo -e "\e[01;34mOutput of '\e[01;33mcommand -v\e[0m\e[01;34m':\e[0m"
    for binary_name_command in "${binary_name_array[@]}"
    do
        \echo "    $(\command -v ${binary_name_command})"
    done

    \echo -e "\n\e[01;34mOutput of '\e[01;33mwhich'\e[0m\e[01;34m:\e[0m"
    for binary_name_which in "${binary_name_array[@]}"
    do
        \echo -e "\n    $(\which ${binary_name_which})"
    done

    \echo -e "\n\e[01;34mOutput of '\e[01;33mtype\e[0m\e[01;34m':\e[0m"
    for binary_name_type in "${binary_name_array[@]}"
    do
        \echo "    $(\type ${binary_name_type})"
    done

    \echo -e "\n\e[01;34mOutput of '\e[01;33mwhereis\e[0m\e[01;34m':\e[0m"
    for binary_name_whereis in "${binary_name_array[@]}"
    do
        \echo "    $(\whereis ${binary_name_whereis})"
    done
}

## do not include faulty commands in history
zshaddhistory()
{
    \whence ${${(z)1}[1]} >| /dev/null || \return 1
}

# prompt shell
## different colours via "ssh"
if \pidof -sq "sshd"
then
    # true
    \export SSH_CONNECTION="1"

    if [[ "${EUID}" == "0" ]]
    then
        \zstyle ':prompt:grml:*:items:user' pre '%B%F{yellow}'
    else
        \zstyle ':prompt:grml:*:items:user' pre '%B%F{magenta}'
    fi
else
    # false
    \export SSH_CONNECTION="0"
fi

# source
## autojump
\source "/usr/share/autojump/autojump.zsh"
## zsh-autosuggestions
\source "/usr/local/share/git/zsh/zsh-autosuggestions/zsh-autosuggestions.zsh"
## zsh-syntax-highlighting
\source "/usr/local/share/git/zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"

# keybindings
\bindkey -r "^N" # up-line-or-history
\bindkey -r "^P" # down-line-or-history
\bindkey "^N" down-line-or-search
\bindkey "^P" up-line-or-search

# aliases
\alias aria2c="aria2c \
                --enable-rpc='false' \
                --rpc-allow-origin-all='false' \
                --rpc-listen-all='false' \
                --force-sequential='true' \
                --continue='true' \
                --auto-save-interval='30' \
                --http-accept-gzip='true' \
                --netrc-path='${HOME}/.cache/aria2/netrc' \
                --max-concurrent-downloads='4' \
                --max-connection-per-server='8' \
                --min-split-size='20M' \
                --split='8' \
                --save-session='${HOME}/.cache/aria2/aria2_session.gz' \
                --save-session-interval='60' \
                --bt-detach-seed-only='true' \
                --bt-enable-lpd='true' \
                --bt-stop-timeout='21600' \
                --check-integrity='true' \
                --seed-ratio='1.0' \
                --seed-time='0' \
                --enable-dht='true' \
                --enable-dht6='true' \
                --dht-listen-port='6881-6999' \
                --dht-file-path='${HOME}/.cache/aria2/dht.dat' \
                --dht-file-path6='${HOME}/.cache/aria2/dht6.dat' \
                --bt-force-encryption='true' \
                --bt-require-crypto='true' \
                --bt-min-crypto-level='arc4' \
                --bt-max-peers='60' \
                --bt-request-peer-speed-limit='50K' \
                --max-overall-upload-limit='400K' \
                --disable-ipv6='false' \
                --event-poll='epoll' \
                --file-allocation='falloc' \
                --max-download-limit='0' \
                --max-overall-download-limit='0' \
                --optimize-concurrent-downloads='true' \
                --min-tls-version='TLSv1.2' \
                --allow-overwrite='true' \
                --auto-file-renaming='false' \
                --conditional-get='true' \
                --remove-control-file='false'"
\alias badblocks="badblocks -sv -o '/tmp/badblocks.log'"
\alias bc="bc --mathlib"
\alias bzgrep="bzgrep --color='auto' --line-number"
\alias cal="cal --color='auto' --week --months='3'"
\alias cdrecord="cdrecord -sao -speed='0' -eject -v"
\alias cdparanoia="cdparanoia --batch --force-read-speed='1' --abort-on-skip --log-summary='cdparanoia.log'"
if [[ "${EUID}" == "0" ]]
then
    \alias cdda2wav="cdda2wav \
                        -verbose-level='all' \
                        -cddb='0' \
                        -speed='1' \
                        -paranoia \
                        -paraopts='proof' \
                        -bulk \
                        -device='/dev/sr0'"
else
    # the package "app-cdr/cdrtools" is broken, even with correct read-write permissions for "/dev/sr0"!
    \alias cdda2wav="sudo cdda2wav \
                        -verbose-level='all' \
                        -cddb='0'  \
                        -speed='1'  \
                        -paranoia  \
                        -paraopts='proof'  \
                        -bulk  \
                        -device='/dev/sr0'"
fi
\alias crontab="crontab -i"
\alias curl="curl --show-error"
\alias dd="dd bs='1M' conv='fsync' status='progress'"
\alias diff="diff --side-by-side --suppress-common-lines --color"
\alias dvdbackup="dvdbackup --progress"
\alias e2fsck="e2fsck -v"
\alias egrep="egrep --color='auto' --line-number"
\alias fallocate="fallocate --verbose"
\alias fatresize="fatresize --progress"
\alias fd="fd --hidden --no-ignore --show-errors"
\alias fgrep="fgrep --color='auto' --line-number"
\alias flac="flac --compression-level-8"
\alias fping="fping --generate --rdns"
\alias growisofs="growisofs -speed='1'"
\alias grep="grep --color='auto' --line-number"
\alias go-mtpfs="echo -e '\e[01;31mRemember to use \"rsync --inplace\", when copying to the Android device!\e[0m' && go-mtpfs -usb-timeout='15000'"
\alias halt="echo 'Are you sure? Please run: /sbin/halt'"
\alias htop="btop"
\alias hexdump="hexdump --canonical"
\alias history="history -i"
\alias iotop="iotop --only --processes --accumulated --delay='2'"
\alias ip="ip --color"
\alias l="ls -vC --classify"
\alias la="ls -v --all"
\alias lbzip2"lbzp2 --best"
\alias listaliases="echo '${(k)aliases// /\n}'"
\alias listcm="echo -e '\e[01;34mContents of \"\e[01;37m${HOME}/.ssh/cm\e[0m\e[01;34m\":\e[0m' && ls -ltr '${HOME}/.ssh/cm'"
\alias listfunctions="echo '${(k)functions// /\n}'"
\alias listgroups="gawk \
                    --field-separator ':' \
                    '{
                        printf \"Group name: %-20s GID: %-10s Members: %-10s\n\", \$1, \$3, \$4;
                     }' '/etc/group' \
                        | sort --numeric-sort --key='5'"
\alias listusers="gawk \
                    --field-separator ':' \
                    '{
                        printf \"Username: %-20s UID: %-10s GID: %-10s Shell: %-10s\n\", \$1, \$3, \$4, \$7;
                     }' '/etc/passwd' \
                        | sort --numeric-sort --key='4'"
\alias listvariables="echo '${(k)parameters// /\n}'"
\alias ll="ls -vl"
\alias ln="ln --verbose"
\alias locate="locate --ignore-case"
\alias lsblk="lsblk --discard --fs --merge --perms --zoned"
\alias mkdir="mkdir --parents"
\alias mktorrent="mktorrent --verbose \
                    --announce='http://tracker.openbittorrent.com:80/announce' \
                    --announce='udp://tracker.internetwarriors.net:1337/announce' \
                    --announce='udp://tracker.opentrackr.org:1337/announce' \
                    --announce='udp://exodus.desync.com:6969/announce' \
                    --announce='udp://tracker.tiny-vps.com:6969/announce' \
                    --announce='udp://retracker.lanta-net.ru:2710/announce' \
                    --announce='udp://tracker.torrent.eu.org:451/announce' \
                    --announce='udp://tracker.moeking.me:6969/announce' \
                    --announce='udp://vibe.community:6969/announce' \
                    --announce='udp://valakas.rollo.dnsabr.com:2710/announce' \
                    --announce='udp://tracker0.ufibox.com:6969/announce' \
                    --announce='udp://tracker.zerobytes.xyz:1337/announce' \
                    --announce='udp://tracker.v6speed.org:6969/announce' \
                    --announce='udp://tracker.uw0.xyz:6969/announce' \
                    --announce='udp://tracker.shkinev.me:6969/announce' \
                    --announce='udp://tracker.nighthawk.pw:2052/announce' \
                    --announce='udp://tracker.lelux.fi:6969/announce'"
\alias ncdu="ncdu --color='dark' --confirm-quit --exclude-kernfs"
\alias nload="nload -u K"
\alias path="echo ${PATH//:/'\n'}"
\alias pcregrep="pcregrep --color='auto' --line-number"
\alias pdfgrep="pdfgrep --page-number='index'"
\alias pigz="pigz --best"
\alias pixz="pixz -9"
\alias plzip="plzip --best"
\alias poweroff="echo 'Are you sure? Please run: /sbin/poweroff'"
\alias radeontop="radeontop --color"
\alias rdesktop="rdesktop \
                    -g 1920x1080 \
                    -P \
                    -z \
                    -x \
                    -l \
                    -r sound:off \
                    -k '/usr/share/rdesktop/keymaps/de'"
\alias reboot="echo 'Are you sure? Please run: /sbin/reboot'"
\alias rsync="rsync \
                --archive \
                --hard-links \
                --acls \
                --xattrs \
                --one-file-system \
                --numeric-ids \
                --info='progress2' \
                --rsh='ssh \
                        -T \
                        -c chacha20-poly1305@openssh.com,aes256-gcm@openssh.com \
                        -o Compression=no -x'"
\alias ruffle="ruffle \
                --gamemode='on' \
                --cache-directory='/var/cache/ruffle' \
                --tcp-connections='deny' \
                --upgrade-to-https \
                --open-url-mode='deny'"
\alias screen_record="ffmpeg \
                        -n \
                        -f x11grab \
                        -video_size 1920x1080 \
                        -framerate 25 \
                        -i '${DISPLAY}.0' \
                        -f alsa \
                        -ac 2 \
                        -i default \
                        -codec:a aac '$(\date +%Y%m%dT%H%M%S%z)_screen_record.mkv'"
\alias shutdown="echo 'Are you sure? Please run: /sbin/shutdown'"
\alias shred="shred --verbose"
\alias sort="sort --parallel='$(\nproc --all)'"
\alias tree="LS_COLORS='' tree -FC"
\alias updatedb="updatedb --require-visibility='yes'"
\alias vmstat="vmstat --unit='M' --timestamp --wide 2"
\alias watch="watch --differences"
\alias webcam_live_capture="mpv \
                                --demuxer-lavf-format='video4linux2' \
                                --profile='low-latency' \
                                --demuxer-lavf-o-set=input_format='mjpeg' \
                                --untimed 'av://v4l2:/dev/video0'"
\alias webcam_record="ffmpeg \
                        -f v4l2 \
                        -framerate 30 \
                        -video_size 1920x1080 \
                        -input_format mjpeg \
                        -i '/dev/video0' \
                        -f alsa \
                        -ac 2 \
                        -i default \
                        -codec:a aac '$(\date +%Y%m%dT%H%M%S%z)_webcam_record.mkv'"
\alias wget="wget --hsts-file='/dev/null'"
\alias xargs="xargs --no-run-if-empty --max-procs=$(\nproc --all) --max-args='1'"
\alias xzgrep="xzgrep --color='auto' --line-number"
\alias xstow="xstow -verbose"
\alias zerofree="zerofree -v"
\alias zip="zip -9"
\alias zipgrep="zipgrep -n"
\alias zstd="zstd --ultra -22 --rm --verbose"
\alias zstdgrep="zstdgrep --color='auto' --line-number"
\alias zstdmt="zstdmt --ultra -22 --rm --verbose"
if [[ "${EUID}" == "0" ]]
then
    \alias joplin="echo -e \"\e[01;31m'joplin' should not be executed with root privileges!\e[0m\""
    \alias pip="echo -e \"\e[01;31m'pip' should not be executed with root privileges!\e[0m\""
fi

# export
## set default text editor
\export EDITOR="nvim"
\export VISUAL="nvim"
## location for x cache
\export XDG_CACHE_HOME="${HOME}/.cache"
## set colours for hard and orphaned symlinks
\export LS_COLORS="mh=44;37:or=40;31;01"
## less
### general settings
\export LESS="--RAW-CONTROL-CHARS --LONG-PROMPT --shift 5 --ignore-case"
### enable syntax highlighting
\export LESSOPEN="| lesspipe.sh %s"
### do not save search entries at "~/.lesshst"
\export LESSHISTFILE="/dev/null"
## do not include certain commands in history
\export ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE="20"
## do not include critical or annoying commands in history
\export HISTORY_IGNORE="(*:*|*--force*|*cd*|*chmod*|*chown*|*clear*|*dd*|*delete*|*exit*|*find*|*for*|*halt*|*hdparm*|*kill*|*mkfs*|*ll*|*lpr*|*ls*|*mv*|*perl-rename*|*poweroff*|*pwd*|*reboot*|*rename*|*remove*|*rm*|*sed*|*shred*|*shutdown*|*sudo*|*suspend*|*touch*|*while*)"
## use "ccache" via "distcc". see also "/etc/conf.d/distccd", "/etc/distcc/hosts", "/etc/env.d/03distcc_ccache" and "/etc/portage/make.conf"
\export PATH="/usr/lib/ccache/bin:${PATH}"
\export CCACHE_DIR="/home/ramon/.var/tmp/ccache"
\export DISTCC_DIR="/home/ramon/.var/tmp/distcc"
## mimic bash's cursor movement for paths
### original string: *?_-.[]~=/&;!#$%^(){}<>
\export WORDCHARS="*?_-.[]~=&;!#$%^(){}<>"
## always use the best compression method of "xz"
\export XZ_OPT="-9"
## workaround for "tmux" to create proper conditionals
\export EUID="${EUID}"
## set default parameters for "progress"
\export PROGRESS_ARGS="--wait-delay='2.0' --monitor-continuously"
## always activate anti-aliasing for "java" apps
\export JDK_JAVA_OPTIONS="-Dawt.useSystemAAFontSettings='lcd'"
## always run "fsck" in parllel. it just needs to be set, no values required.
export FSCK_FORCE_ALL_PARALLEL=""

# output when opening shell
## list who is logged in
\who --users
## list tmux sessions
if pgrep --euid "${USER}" "tmux" >/dev/null
then
    \tmux ls
fi
## portage
### last synchronisation in days
getLastPortageSync
