#############################################################################
# Copyright 2020-2022 Ramon Fischer                                         #
#                                                                           #
# Licensed under the Apache License, Version 2.0 (the "License");           #
# you may not use this file except in compliance with the License.          #
# You may obtain a copy of the License at                                   #
#                                                                           #
#     http://www.apache.org/licenses/LICENSE-2.0                            #
#                                                                           #
# Unless required by applicable law or agreed to in writing, software       #
# distributed under the License is distributed on an "AS IS" BASIS,         #
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  #
# See the License for the specific language governing permissions and       #
# limitations under the License.                                            #
#############################################################################

# functions
## translate words (english-german,german-english)
dic()
{
    input_string=${*// /+}
    w3m -dump "https://pocket.dict.cc/?s=${input_string}" | head --lines="-6" | tail --lines="+6" | tac
}

## generate and check file checksums via "blake2" in parallel
gsum()
{
    local checksum_file="./checksums.b2"
    local available_processors=$(nproc --all --ignore="1")
    local xargs_max_args="1"
    local overwrite_checksum_file
    local file_list

    if [[ -f "${checksum_file}" ]]
    then
        read $'overwrite_checksum_file?\e[01;31mThe file: '"'${checksum_file}'"$' already exists. Do you really want to overwrite it? (y/N): \e[0m' >&2
        if [[ "${overwrite_checksum_file:-n}" =~ [nN] ]]
        then
            return 1
        fi
    fi

    file_list=$(find "." \
                    -type f \
                    -not \
                    -name "${checksum_file/\.\//}" \
                    -print0)

    # the command "printf" is important here to keep a null-character-separated string.
    # using "here-string" ("<<<") would add a trailing newline.
    xargs \
        --null \
        --max-procs="${available_processors}" \
        --max-args="${xargs_max_args}" \
        b2sum --zero > "${checksum_file}" < <(printf "%s" "${file_list}")
}
csum()
{
    local checksum_file="./checksums.b2"
    local available_processors=$(nproc --all --ignore="1")

    if [[ ! -f "${checksum_file}" ]]
    then
        echo -e "\e[01;31mThe file: '${checksum_file}' could not be found or is not a file.\e[0m" >&2
        return 1
    else
        # the parameter "--replace" and a subshell ("sh") must be used here!
        xargs \
            --null \
            --arg-file="${checksum_file}" \
            --max-procs="${available_processors}" \
            --replace="{}" \
            sh -c \
                "b2sum --check --quiet <<< '{}'"
    fi
}

## prepare and "unprepare" a chroot environment conveniently
pchroot()
{
    if [[ "${EUID}" == "0" ]]
    then
        declare -a system_directory_array
        system_directory_array=("/proc/" "/sys/" "/dev/")
        local system_directory
        declare -a chroot_directory_array
        chroot_directory_array=("./proc/" "./sys/" "./dev/")
        local chroot_directory

        for system_directory in "${system_directory_array[@]}"
        do
            if [[ ! -d "${system_directory}" ]]
            then
                echo -e "\e[01;31mThe system directory: '${system_directory}' could not be found or is not a directory.\e[0m" >&2
                return 1
            fi
        done

        for chroot_directory in "${chroot_directory_array[@]}"
        do
            if [[ ! -d "${chroot_directory}" ]]
            then
                echo -e "\e[01;31mThe chroot directory: '${chroot_directory}' could not be found or is not a directory.\e[0m" >&2
                return 1
            fi
        done

        mount --verbose --types proc "${system_directory_array[1]}" "${chroot_directory_array[1]}"
        mount --verbose --rbind "${system_directory_array[2]}" "${chroot_directory_array[2]}"
        mount --verbose --make-rslave "${chroot_directory_array[2]}"
        mount --verbose --rbind "${system_directory_array[3]}" "${chroot_directory_array[3]}"
        mount --verbose --make-rslave "${chroot_directory_array[3]}"

        echo -e "\e[01;33mPrepared the chroot environment.\e[0m\n" >&2
        echo -e "\e[01;33mExecute the following command to enter it: chroot . \"/bin/bash\"\e[0m" >&2
        echo -e "\e[01;33mIf the CPU architectures differ, the binary \"qemu-<arch>-static\" may be used: cp \"qemu-<arch>-static\" \"usr/bin/\" && chroot . qemu-<arch>-static \"/bin/bash\"\e[0m" >&2
        echo -e "\e[01;33mExecute the following command to prepare the environment within the chroot: source \"/etc/profile\" && export PS1=\"(chroot) \${PS1}\"\e[0m" >&2
    else
        echo -e "\e[01;31mEntering a chroot environment requires root privileges!\e[0m" >&2
        return 1
    fi
}
uchroot()
{
    if [[ "${EUID}" == "0" ]]
    then
        declare -a chroot_directory_array
        chroot_directory_array=("./proc/" "./sys/" "./dev/")
        local chroot_directory

        for chroot_directory in "${chroot_directory_array[@]}"
        do
            if [[ ! -d "${chroot_directory}" ]]
            then
                echo -e "\e[01;31mThe chroot directory: '${chroot_directory}' could not be found or is not a directory.\e[0m" >&2
                return 1
            elif ! mountpoint --quiet "${chroot_directory}"
            then
                echo -e "\e[01;31mThe chroot directory: '${chroot_directory}' is not mounted.\e[0m" >&2
            fi
        done

        umount --verbose --lazy --recursive ${chroot_directory_array[@]}

        echo -e "\e[01;33mUnprepared the chroot environment.\e[0m" >&2
    else
        echo -e "\e[01;31mUnpreparing a chroot environment requires root privileges!\e[0m" >&2
        return 1
    fi
}

## toggle exclude remove feature via "globbing"
exclude_remove_on()
{
    setopt extended_glob
    echo -e "\e[01;31mGlob syntax has been activated.\e[0m"
    echo "Examples:"
    echo "Remove all files, except the file 'nom': rm -- ^\"nom\""
    echo "Remove all files, except files with the suffix 'png' and 'jpg': rm -- ^.*(png|jpg)"
}
exclude_remove_off()
{
    unsetopt extended_glob
    echo -e "\e[01;31mGlob syntax has been deactivated.\e[0m"
}

## print invoice files in chronological descending order
lpr_invoice()
{
    local directory_file_list=$(ls -1t)
    local directory_file
    declare -a invoice_file_array
    local print_files
    local invoice_index_number="1"

    if [[ "${directory_file_list}" != "" ]]
    then
        while read -r directory_file
        do
            if [[ -f "${directory_file}" ]]
            then
                invoice_file_array+=("${directory_file}")
                echo -e "\e[01;35m${invoice_index_number}: ${directory_file}\e[0m"
                (( invoice_index_number++ ))
            fi
        done <<< "${directory_file_list}"

        if [[ "${invoice_file_array[@]}" != "" ]]
        then
            read $'print_files?\e[01;31mDo you really want to print the above files in this particular order? (y/N): \e[0m' >&2

            case "${print_files:-n}" in
                "y"|"Y")
                    lpr "${invoice_file_array[@]}"
                    ;;

                "n"|"N")
                    return 1
                    ;;

                *)
                    echo -e "\e[01;31mWrong input: '${print_files}'.\e[0m" >&2
                    return 1
            esac
        else
            echo -e "\e[01;31mThe invoice file array: '${invoice_file_array[@]}' is empty. Nothing to do...\e[0m" >&2
            return 1
        fi
    else
        echo -e "\e[01;31mThe directory file list: '${directory_file_list}' is empty. Nothing to do...\e[0m" >&2
        return 1
    fi
}

## generate strong passwords with ~130 bit entropy
genpw()
{
    local -i password_length=24
    local remove_characters="[:space:]"
    local -i password_count=20
    local password_output
    local password_entropy
    local entropy_result
    local lowercase_letter_regex="[a-z]"
    local lowercase_letter_amount="26"
    local uppercase_letter_regex="[A-Z]"
    local uppercase_letter_amount="26"
    local numeric_regex="[0-9]"
    local numeric_amount="10"
    local ascii_character_string="[[:punct:]]"
    local ascii_character_amount="32"

    while (( ${#} ))
    do
        case "${1}" in
            "-a" | "--no-lowercase")
                remove_characters+="a-z"
                ;;

            "-A" | "--no-uppercase")
                remove_characters+="A-Z"
                ;;

            "-c" | "--count")
                password_count="${2}"
                shift
                ;;

            "-l" | "--length")
                password_length="${2}"
                shift
                ;;

            "-n" | "--no-numbers")
                remove_characters+="0-9"
                ;;

            "-s" | "--no-special")
                remove_characters+="[:punct:]"
                ;;

            "-h" | "--help")
                echo ""
                echo "Usage: ${0} [options]... <arguments>..."
                echo ""
                echo "OPTIONS:"
                echo "  -a, --no-lowercase              exclude lowercase characters"
                echo "  -A, --no-uppercase              excluce uppercase characters"
                echo "  -c, --count <number>            define the amount of generated passwords"
                echo "  -l, --length <number>           define password length"
                echo "  -n, --no-numbers                exclude numeric characters"
                echo "  -s, --no-special                exclude special characters"
                echo "  -h, --help                      show this message"
                echo ""
                echo "EXAMPLES:"
                echo "  generate a password with 24 characters"
                echo "      ${0} --length 24"
                echo ""
                echo "  exclude special and uppercase characters"
                echo "      ${0} --no-special --no-uppercase"
                return 0
        esac
        shift 1 >/dev/null 2>&1 || break
    done

    for i in {1..${password_count}}
    do
        password_entropy="0"
        password_output=$(strings --bytes="1" "/dev/urandom" | tr --delete "${remove_characters}" | head --bytes="${password_length}")

        if [[ "${password_output}" =~ "${lowercase_letter_regex}" ]]
        then
            # add 26
            (( password_entropy+=lowercase_letter_amount ))
        fi
        if [[ "${password_output}" =~ "${uppercase_letter_regex}" ]]
        then
            # add 26
            (( password_entropy+=uppercase_letter_amount ))
        fi
        if [[ "${password_output}" =~ "${numeric_regex}" ]]
        then
            # add 10
            (( password_entropy+=numeric_amount ))
        fi
        if [[ "${password_output}" =~ "${ascii_character_string}" ]]
        then
            # add 32
            (( password_entropy+=ascii_character_amount ))
        fi

        entropy_result=$(awk \
            --assign="password_entropy=${password_entropy}" '\
            {
                printf "%.4f", log(password_entropy^$0)/log(2);
            }' <<< "${password_length}")

        printf "%s    %s bit (%s)\n" "${password_output}" "${entropy_result}" "${password_entropy}"
    done
}

## determine last portage synchronisation
getLastPortageSync()
{
    local portage_timestamp_file="/var/db/repos/gentoo/metadata/timestamp.chk"

    if [[ ! -f "${portage_timestamp_file}" ]]
    then
        echo -e "\e[01;31mThe file: '${portage_timestamp_file}' could not be found or is not a file.\e[0m" >&2
        return 1
    else
        local current_unix_time="$(date +%s)"
        local portage_unix_time="$(date --date="$(< ${portage_timestamp_file})" +%s)"
        local days_since_last_sync="$(( (${current_unix_time} - ${portage_unix_time}) / 86400.0 ))"
    fi

    if (( ${days_since_last_sync} >= 3.5 && ${days_since_last_sync} < 7 ))
    then
        printf "\e[01;33m[%.2f] days since last portage synchronisation.\e[0m\n" "${days_since_last_sync}"
    elif (( ${days_since_last_sync} >= 7 ))
    then
        printf "\e[01;31;5m[%.2f] days since last portage synchronisation!\e[0m \e[01;31m(execute as root: /root/bin/update.sh)\e[0m\n" "${days_since_last_sync}"
    elif [[ "${1}" == "-v" ]]
    then
        printf "\e[01;34m[%.2f] days since last portage synchronisation.\e[0m\n" "${days_since_last_sync}"
    else
        printf ""
    fi
}

## list all process signals
lsig()
{
    echo "1:  SIGHUP"
    echo "2:  SIGINT"
    echo "3:  SIGQUIT"
    echo "4:  SIGKILL"
    echo "5:  SIGTRAP"
    echo "6:  SIGABRT"
    echo "7:  SIGBUS"
    echo "8:  SIGFPE"
    echo "9:  SIGKILL"
    echo "10: SIGUSR1"
    echo "11: SIGSEGV"
    echo "12: SIGUSR2"
    echo "13: SIGPIPE"
    echo "14: SIGALRM"
    echo "15: SIGTERM"
    echo "16: SIGSTKFLT"
    echo "17: SIGCHLD"
    echo "18: SIGCONT"
    echo "19: SIGSTOP"
    echo "20: SIGTSTP"
    echo "21: SIGTTIN"
    echo "22: SIGTTOU"
    echo "23: SIGURG"
    echo "24: SIGXCPU"
    echo "25: SIGXFSZ"
    echo "26: SIGVTALRM"
    echo "27: SIGPROF"
    echo "28: SIGWINCH"
    echo "29: SIGIO"
    echo "30: SIGPWR"
    echo "31: SIGSYS"
    echo "32: Not defined"
    echo "33: Not defined"
    echo "34: SIGRTMIN"
    echo "35: SIGRTMIN+1"
    echo "36: SIGRTMIN+2"
    echo "37: SIGRTMIN+3"
    echo "38: SIGRTMIN+4"
    echo "39: SIGRTMIN+5"
    echo "40: SIGRTMIN+6"
    echo "41: SIGRTMIN+7"
    echo "42: SIGRTMIN+8"
    echo "43: SIGRTMIN+9"
    echo "44: SIGRTMIN+10"
    echo "45: SIGRTMIN+11"
    echo "46: SIGRTMIN+12"
    echo "47: SIGRTMIN+13"
    echo "48: SIGRTMIN+14"
    echo "49: SIGRTMIN+15"
    echo "50: SIGRTMAX-14"
    echo "51: SIGRTMAX-13"
    echo "52: SIGRTMAX-12"
    echo "53: SIGRTMAX-11"
    echo "54: SIGRTMAX-10"
    echo "55: SIGRTMAX-9"
    echo "56: SIGRTMAX-8"
    echo "57: SIGRTMAX-7"
    echo "58: SIGRTMAX-6"
    echo "59: SIGRTMAX-5"
    echo "60: SIGRTMAX-4"
    echo "61: SIGRTMAX-3"
    echo "62: SIGRTMAX-2"
    echo "63: SIGRTMAX-1"
    echo -e "64: SIGRTMAX\n"
    echo "See also: man 7 signal"
}

## monitor a single process
pmon()
{
    local process_name="${1}"
    local watch_interval="${2:-0.1}"
    local process_name_last_character="${process_name:(-1)}"
    local search_string="${process_name/%${process_name_last_character}/[${process_name_last_character}]}"

    # use the command "command watch" and "command ps"
    # in order to use them as unaliased commands.
    # the command "unalias" could be used here, but once executed,
    # this would affect the current shell.
    command watch --differences --interval "${watch_interval}" \
        "awk --assign search_string="${search_string}" \
            'NR == 1; \$0 ~ search_string' < <(command ps faux)"
}

## notify after a command has finished
## usage: notifyme <some_command>
notifyme()
{
    local -i start_time="$(date +%s)"

    "${@}"

    local end_time="$(date +%s)"
    local total_execution_time="$(( end_time - start_time ))"
    #if (( total_execution_time >= 15 ))
    #then
        notify-send --app-name="Notification" --icon="notifications" --urgency="critical" "Command finished [${total_execution_time} seconds]" "'$(echo ${@})'"
    #fi
}

## list real and effective user and group ids in a more convenient way
listids()
{
    declare -a username_array
    username_array=("${@}")
    local username
    declare -A username_id_array
    local username_id
    local id_name_list

    # fill associative array
    for username in "${username_array[@]}"
    do
        id_name_list=$(id "${username}")

        if [[ "${id_name_list}" == "" ]]
        then
            continue
        else
            username_id_array[${username}]="${id_name_list}"
        fi
    done

    # output associative array
    for username_id in ${(k)username_id_array}
    do
        echo -e "\e[01;34mIDs of the user '\e[01;33m${username_id}\e[0m\e[01;34m':\e[0m"
        awk --field-separator ',' '{ gsub("[, ]", "\n    "); sub("^", "    "); print $0"\n"}' <<< ${username_id_array[${username_id}]}
    done
}

## bash: execute bell when command is finished
precmd()
{
    eval "${PROMPT_COMMAND}"
}
PROMPT_COMMAND+='tput bel;'

## dynamically change the window title for terminals
if [[ "${TERM}" != "" && "${TERM}" == "st"* || "${TERM}" == "alacritty" ]]
then
    precmd()
    {
        # output on which level (%L) this shell is running on.
        # append the current directory (%~), substitute home directories with a tilde.
        # "\a" bell (man 1 echo)
        # "print" must be used here; echo cannot handle prompt expansions (%L)
        print -Pn "\e]0;${USER}@${HOSTNAME}: zsh[%L] %~\a"
    }

    preexec()
    {
        # output current executed command with parameters
        echo -en "\e]0;${USER}@${HOSTNAME}: ${1}\a"
    }
fi


## list access, owner and group permission tree for the current or defined working directory
ptree()
{
    local directory_path="${1:-$(pwd)}"
    namei --long --mountpoints "${directory_path}"
}

## upload files to "transfer.sh"
transfer()
{
    local file
    declare -a file_array
    file_array=("${@}")

    if [[ "${file_array[@]}" == "" || "${1}" == "--help" || "${1}" == "-h" ]]
    then
        echo "${0} - Upload arbitrary files to \"transfer.sh\"."
        echo ""
        echo "Usage: ${0} [options] [<file>]..."
        echo ""
        echo "OPTIONS:"
        echo "  -h, --help"
        echo "      show this message"
        echo ""
        echo "EXAMPLES:"
        echo "  Upload a single file from the current working directory:"
        echo "      ${0} \"image1.img\""
        echo ""
        echo "  Upload multiple files from the current working directory:"
        echo "      ${0} \"image1.img\" \"image2.img\""
        echo ""
        echo "  Upload multiple files with spaces in their filename from the current working directory:"
        echo "      ${0} \"image 1.img\" image\ 2.img"
        echo ""
        echo "  Upload a file from a different directory:"
        echo "      ${0} \"/tmp/image1.img\""
        echo ""
        echo "  Upload multiple files from a different directory:"
        echo "      ${0} transfer /tmp/{image1.img,image\ 1.img,\"image 2.img\"}"
        echo ""
        echo "  Upload all files from the current working directory. Be aware of the webserver's rate limiting!:"
        echo "      ${0} *"
        echo ""
        echo "  Upload a single file from the current working directory and filter out the delete token and download link:"
        echo "      ${0} \"image.img\" | awk --field-separator=\": \" '/Delete token:/ { print \$2 } /Download link:/ { print \$2 }'"
        echo ""
        echo "  Show help text from \"transfer.sh\":"
        echo "      curl --request GET \"https://transfer.sh\""
        return 0
    else
        for file in "${file_array[@]}"
        do
            if [[ ! -f "${file}" ]]
            then
                echo -e "\e[01;31mThe file: '${file}' could not be found or is not a file.\e[0m" >&2
                return 1
            fi
        done
        unset file
    fi

    local upload_files
    local curl_output
    local awk_output
    local url_filename

    du --total --block-size="K" --dereference "${file_array[@]}" >&2
    # be compatible with "bash"
    if [[ "${ZSH_NAME}" == "zsh" ]]
    then
        read $'upload_files?\e[01;31mDo you really want to upload the above files ('"${#file_array[@]}"$') to "transfer.sh"? (y/N): \e[0m' >&2
    elif [[ "${BASH}" == *"bash"* ]]
    then
        read -p $'\e[01;31mDo you really want to upload the above files ('"${#file_array[@]}"$') to "transfer.sh"? (y/N): \e[0m' upload_files >&2
    fi

    case "${upload_files:-n}" in
        "y"|"Y")
            # for the sake of the progress bar, execute "curl" for each file.
            # the parameters "--include" and "--form" will suppress the progress bar.
            for file in "${file_array[@]}"
            do
                url_filename="${file##*/}"
                url_filename="${url_filename// /%20}"
                # show delete link and filter out the delete token from the response header after upload.
                # it is important to save "curl's" "stdout" via a subshell to a variable or redirect it to another command,
                # which just redirects to "stdout" in order to have a sane output afterwards.
                # the progress bar is redirected to "stderr" and is only displayed,
                # if "stdout" is redirected to something; e.g. ">/dev/null", "tee /dev/null" or "| <some_command>".
                # the response header is redirected to "stdout", so redirecting "stdout" to "/dev/null" does not make any sense.
                # redirecting "curl's" "stderr" to "stdout" ("2>&1") will suppress the progress bar.
                curl_output=$(curl --request PUT --progress-bar --dump-header - --upload-file "${file}" "https://transfer.sh/${url_filename}")
                awk_output=$(awk \
                    'gsub("\r", "", $0) && tolower($1) ~ /x-url-delete/ \
                    {
                        delete_link=$2;
                        print "Delete command: curl --request DELETE " "\""delete_link"\"";

                        delete_token=gensub(".*/", "", "g", delete_link);
                        print "Delete token: " delete_token;
                    }

                    END{
                        print "Download link: " $0;
                    }' <<< "${curl_output}")

                # return the results via "stdout", "awk" does not do this for some reason.
                echo -e "${awk_output}\n"

                # avoid rate limiting as much as possible; nginx: too many requests.
                if (( ${#file_array[@]} > 4 ))
                then
                    sleep 5
                fi
            done
            ;;

        "n"|"N")
            return 1
            ;;

        *)
            echo -e "\e[01;31mWrong input: '${upload_files}'.\e[0m" >&2
            return 1
    esac
}

thingsIalwaysForget()
{
    echo -e "\e[01;34miproute2:\e[0m"
    echo "  Configure a static IP address:"
    echo "      ip address add <local_ip_address>/<cidr_subnet_mask> dev <inferface>"
    echo ""
    echo "  Configure a default gateway:"
    echo "      ip route add default via <default_gateway> dev <interface>"
    echo ""
    echo -e "\e[01;34mTranslations:\e[0m"
    echo "  anticipate - ahnen, erhoffen"
}

## get current wan ip address
wan()
{
    declare -a ip_version_array
    ip_version_array=("ipv4" "ipv6")
    local ip_version

    for ip_version in "${ip_version_array[@]}"
    do
        echo -n "${ip_version}: "
        curl --request GET --silent --show-error --"${ip_version}" "https://ifconfig.co/"
    done
}

## get weather forecast information
weather()
{
    local input_string="${*// /+}"

    if [[ "${input_string}" == "--help" || "${input_string}" == "-h" ]]
    then
        input_string=":help"
    fi

    curl --request GET --silent --show-error "https://wttr.in/${input_string}"
}

## output the paths to binary files from "${PATH}" and functions of the current shell
wherefrom()
{
    declare -a binary_name_array
    binary_name_array=("${@}")
    local binary_name_command
    local binary_name which
    local binary_name_whereis

    #unalias "${binary_name_array[@]}" 2>/dev/null

    echo -e "\e[01;34mOutput of 'command -v':\e[0m"
    for binary_name_command in "${binary_name_array[@]}"
    do
        echo "    $(command -v ${binary_name_command})"
    done

    echo -e "\n\e[01;34mOutput of 'which':\e[0m"
    for binary_name_which in "${binary_name_array[@]}"
    do
        echo -e "    $(which ${binary_name_which})\n"
    done

    echo -e "\n\e[01;34mOutput of 'whereis':\e[0m"
    for binary_name_whereis in "${binary_name_array[@]}"
    do
        echo "    $(whereis ${binary_name_whereis})"
    done

}

## do not include faulty commands in history
zshaddhistory()
{
    whence ${${(z)1}[1]} >| /dev/null || return 1
}

# prompt shell
## colour
#if [[ "${EUID}" == "0" ]]
#then
#    zstyle ':prompt:grml:*:items:user' pre '%F{yellow}'
#else
#    zstyle ':prompt:grml:*:items:user' pre '%F{magenta}'
#fi

# source
## autojump
source "/usr/share/autojump/autojump.zsh"
## zsh-autosuggestions
source "/usr/local/share/git/zsh/zsh-autosuggestions/zsh-autosuggestions.zsh"
## zsh-syntax-highlighting
source "/usr/local/share/git/zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"

# keybindings
bindkey -r "^N" # up-line-or-history
bindkey -r "^P" # down-line-or-history
bindkey "^N" down-line-or-search
bindkey "^P" up-line-or-search

# aliases
alias aria2c="aria2c --enable-rpc='false' \
    --rpc-allow-origin-all='false' \
    --rpc-listen-all='false' \
    --force-sequential='true' \
    --continue='true' \
    --auto-save-interval='30' \
    --http-accept-gzip='true' \
    --netrc-path='${HOME}/.cache/aria2/netrc' \
    --max-concurrent-downloads='4' \
    --max-connection-per-server='8' \
    --min-split-size='20M' \
    --split='8' \
    --save-session='${HOME}/.cache/aria2/aria2_session.gz' \
    --save-session-interval='60' \
    --bt-detach-seed-only='true' \
    --bt-enable-lpd='true' \
    --bt-stop-timeout='21600' \
    --check-integrity='true' \
    --seed-ratio='1.0' \
    --seed-time='0' \
    --enable-dht='true' \
    --enable-dht6='true' \
    --dht-listen-port='6881-6999' \
    --dht-file-path='${HOME}/.cache/aria2/dht.dat' \
    --dht-file-path6='${HOME}/.cache/aria2/dht6.dat' \
    --bt-force-encryption='true' \
    --bt-require-crypto='true' \
    --bt-min-crypto-level='arc4' \
    --bt-max-peers='60' \
    --bt-request-peer-speed-limit='50K' \
    --max-overall-upload-limit='400K' \
    --disable-ipv6='false' \
    --event-poll='epoll' \
    --file-allocation='falloc' \
    --max-download-limit='0' \
    --max-overall-download-limit='0' \
    --optimize-concurrent-downloads='true' \
    --min-tls-version='TLSv1.2' \
    --allow-overwrite='true' \
    --auto-file-renaming='false' \
    --conditional-get='true' \
    --remove-control-file='false'"
alias bc="bc --mathlib"
alias cdrecord="cdrecord -sao -speed='0' -eject -v"
alias crontab="crontab -i"
alias curl="curl --show-error"
alias dd="dd bs='512b' conv='fsync' status='progress'"
alias diff="diff --side-by-side --suppress-common-lines --color"
alias dvdbackup="dvdbackup --progress"
alias fallocate="fallocate --verbose"
alias fping="fping --generate --rdns"
alias growisofs="growisofs -speed='1'"
alias go-mtpfs="go-mtpfs -usb-timeout='15000'"
alias halt="echo 'Are you sure? Please run: /sbin/halt'"
alias hexdump="hexdump --canonical"
alias history="history -i"
alias iotop="iotop --only --processes --accumulated --delay='2'"
alias ip="ip --color"
alias l="ls -vC --classify"
alias la="ls -v --all"
alias lbzip2"lbzp2 --best"
alias listaliases="echo '${(k)aliases// /\n}'"
alias listfunctions="echo '${(k)functions// /\n}'"
alias listgroups="awk --field-separator ':' '{ printf \"Group name: %-20s GID: %-10s Members: %-10s\n\", \$1, \$3, \$4 }' '/etc/group' | sort --numeric-sort --key='5'"
alias listusers="awk --field-separator ':' '{ printf \"Username: %-20s UID: %-10s GID: %-10s Shell: %-10s\n\", \$1, \$3, \$4, \$7 }' '/etc/passwd' | sort --numeric-sort --key='4'"
alias listvariables="echo '${(k)parameters// /\n}'"
alias ll="ls -vl"
alias ln="ln --verbose"
alias locate="locate --ignore-case"
alias lsblk="lsblk --discard --fs --merge --perms --zoned"
alias mkdir="mkdir --parents"
alias mktorrent="mktorrent --verbose \
    --announce='http://tracker.openbittorrent.com:80/announce' \
    --announce='udp://tracker.internetwarriors.net:1337/announce' \
    --announce='udp://tracker.opentrackr.org:1337/announce' \
    --announce='udp://exodus.desync.com:6969/announce' \
    --announce='udp://tracker.tiny-vps.com:6969/announce' \
    --announce='udp://retracker.lanta-net.ru:2710/announce' \
    --announce='udp://tracker.torrent.eu.org:451/announce' \
    --announce='udp://tracker.moeking.me:6969/announce' \
    --announce='udp://vibe.community:6969/announce' \
    --announce='udp://valakas.rollo.dnsabr.com:2710/announce' \
    --announce='udp://tracker0.ufibox.com:6969/announce' \
    --announce='udp://tracker.zerobytes.xyz:1337/announce' \
    --announce='udp://tracker.v6speed.org:6969/announce' \
    --announce='udp://tracker.uw0.xyz:6969/announce' \
    --announce='udp://tracker.shkinev.me:6969/announce' \
    --announce='udp://tracker.nighthawk.pw:2052/announce' \
    --announce='udp://tracker.lelux.fi:6969/announce'"
alias ncdu="ncdu --color='dark' --confirm-quit --exclude-kernfs"
alias nload="nload -u K"
alias path="echo ${PATH//:/'\n'}"
alias poweroff="echo 'Are you sure? Please run: /sbin/poweroff'"
alias pigz="pigz --best"
alias pixz="pixz -9"
alias plzip="plzip --best"
alias ps="ps axo user,group,uid,gid,ppid,pid,pgid,sid,sgid,%cpu,%mem,vsz,rss,tty,stat,start,time,comm,args=ARGS"
alias pstree="pstree --unicode --arguments --highlight-all --show-pids --show-pgids --numeric-sort"
alias radeontop="radeontop --color"
alias rdesktop="rdesktop -g 1920x1080 -P -z -x -l -r sound:off -k '/usr/share/rdesktop/keymaps/de'"
alias reboot="echo 'Are you sure? Please run: /sbin/reboot'"
alias rsync="rsync --archive --hard-links --acls --xattrs --one-file-system --numeric-ids --info='progress2' --rsh='ssh -T -c chacha20-poly1305@openssh.com,aes256-gcm@openssh.com -o Compression=no -x'"
alias shutdown="echo 'Are you sure? Please run: /sbin/shutdown'"
alias shred="shred --verbose"
alias tree="LS_COLORS='' tree -FC"
alias vmstat="vmstat --unit='M' --timestamp --wide 2"
alias watch="watch --differences"
alias webcam_live_capture="mpv --demuxer-lavf-format='video4linux2' --profile='low-latency' --demuxer-lavf-o-set=input_format='mjpeg' --untimed 'av://v4l2:/dev/video0'"
alias webcam_record="ffmpeg -f v4l2 -framerate 30 -video_size 1920x1080 -input_format mjpeg -i /dev/video0 -f alsa -i default -c:a aac '$(date +%Y%m%d)_webcam_record.mkv'"
alias wget="wget --hsts-file='/dev/null'"
alias xargs="xargs --max-procs='$(nproc --all --ignore="1")' --max-args='1'"
alias xstow="xstow -verbose"
alias youtube-dl_720p="\youtube-dl --format='best[height=720]'"
alias youtube-dl_1080p="\youtube-dl --format='best[height=1080]'"
alias zerofree="zerofree -v"
alias zip="zip -9"
alias zstd="zstd -22 --verbose"
alias zstdmt="zstdmt -22 --verbose"
if [[ "${EUID}" == "0" ]]
then
    alias pip="echo -e \"\e[01;31m'pip' should not be executed with root privileges!\e[0m\""
fi

# export
## set default text editor
export EDITOR="nvim"
export VISUAL="nvim"
## location for x cache
export XDG_CACHE_HOME="${HOME}/.cache"
## set colours for hard and orphaned symlinks
export LS_COLORS="mh=44;37:or=40;31;01"
## less
### general settings
export LESS="--RAW-CONTROL-CHARS --LONG-PROMPT --shift 5 --ignore-case"
### enable syntax highlighting
export LESSOPEN="| lesspipe.sh %s"
### do not save search entries at "~/.lesshst"
export LESSHISTFILE="/dev/null"
## do not include certain commands in history
export ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE="20"
## do not include critical commands in history
export HISTORY_IGNORE="(*--force*|*cd*|*chmod*|*chown*|*clear*|*dd*|*delete*|*exit*|*find*|*for*|*halt*|*kill*|*mkfs*|*lpr*|*ls*|*mv*|*perl-rename*|*poweroff*|*pwd*|*reboot*|*rename*|*remove*|*rm*|*sed*|*shred*|*shutdown*|*sudo*|*suspend*|*touch*|*while*)"
## use "ccache" via "distcc". see also "/etc/conf.d/distccd", "/etc/distcc/hosts", "/etc/env.d/03distcc_ccache" and "/etc/portage/make.conf"
export PATH="/usr/lib/ccache/bin:${PATH}"
export CCACHE_DIR="/home/ramon/.var/tmp/ccache"
export DISTCC_DIR="/home/ramon/.var/tmp/distcc"
## mimic bash's cursor movement for paths
### original string: *?_-.[]~=/&;!#$%^(){}<>
export WORDCHARS="*?_-.[]~=&;!#$%^(){}<>"
## always use the best compression method of "xz"
export XZ_OPT="-9"
## workaround for "tmux" to create proper conditionals
export EUID="${EUID}"

# output when opening shell
## list who is logged in
who
## list tmux sessions
if [[ $(pgrep "tmux") ]]
then
    tmux ls
fi
## portage
### last synchronisation in days
getLastPortageSync
