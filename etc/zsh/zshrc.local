#############################################################################
# Copyright 2020-2022 Ramon Fischer                                         #
#                                                                           #
# Licensed under the Apache License, Version 2.0 (the "License");           #
# you may not use this file except in compliance with the License.          #
# You may obtain a copy of the License at                                   #
#                                                                           #
#     http://www.apache.org/licenses/LICENSE-2.0                            #
#                                                                           #
# Unless required by applicable law or agreed to in writing, software       #
# distributed under the License is distributed on an "AS IS" BASIS,         #
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  #
# See the License for the specific language governing permissions and       #
# limitations under the License.                                            #
#############################################################################

# functions
## translate words (english-german,german-english)
dic()
{
    input_string=${*// /+}
    \w3m -dump "https://pocket.dict.cc/?s=${input_string}" | \head --lines="-6" | \tail --lines="+6" | \tac
}

calc()
{
    local input="${*}"

    \gawk 'BEGIN{ printf("%f", '"${input}"') }'
}

## generate and check file checksums via "blake2" in parallel
gsum()
{
    local checksum_file="./checksums.b2"
    local available_processors=$(\nproc --all --ignore="1")
    local xargs_max_args="1"
    local overwrite_checksum_file
    local file_list

    if [[ -f "${checksum_file}" ]]
    then
        read $'overwrite_checksum_file?\e[01;31mThe file: '"'${checksum_file}'"$' already exists. Do you really want to overwrite it? (y/N): \e[0m' >&2
        if [[ "${overwrite_checksum_file:-n}" =~ [nN] ]]
        then
            return 1
        fi
    fi

    file_list=$(\find "." \
                    -type f \
                    -not \
                    -name "${checksum_file/\.\//}" \
                    -print0)

    # the command "printf" is important here to keep a null-character-separated string.
    # using "here-string" ("<<<") would add a trailing newline.
    \xargs \
        --null \
        --max-procs="${available_processors}" \
        --max-args="${xargs_max_args}" \
        \b2sum --zero > "${checksum_file}" < <(printf "%s" "${file_list}")
}
csum()
{
    local checksum_file="./checksums.b2"
    local available_processors=$(\nproc --all --ignore="1")

    if [[ ! -f "${checksum_file}" ]]
    then
        echo -e "\e[01;31mThe file: '${checksum_file}' could not be found or is not a file.\e[0m" >&2
        return 1
    else
        # the parameter "--replace" and a subshell ("sh") must be used here!
        \xargs \
            --null \
            --arg-file="${checksum_file}" \
            --max-procs="${available_processors}" \
            --replace="{}" \
            \sh -c \
                "\b2sum --check --quiet <<< '{}'"
    fi
}

## prepare and "unprepare" a chroot environment conveniently
pchroot()
{
    if [[ "${EUID}" == "0" ]]
    then
        declare -a system_directory_array
        system_directory_array=("/proc/" "/sys/" "/dev/")
        local system_directory
        declare -a chroot_directory_array
        chroot_directory_array=("./proc/" "./sys/" "./dev/")
        local chroot_directory

        for system_directory in "${system_directory_array[@]}"
        do
            if [[ ! -d "${system_directory}" ]]
            then
                echo -e "\e[01;31mThe system directory: '${system_directory}' could not be found or is not a directory.\e[0m" >&2
                return 1
            fi
        done

        for chroot_directory in "${chroot_directory_array[@]}"
        do
            if [[ ! -d "${chroot_directory}" ]]
            then
                echo -e "\e[01;31mThe chroot directory: '${chroot_directory}' could not be found or is not a directory.\e[0m" >&2
                return 1
            fi
        done

        \mount --verbose --types proc "${system_directory_array[1]}" "${chroot_directory_array[1]}"
        \mount --verbose --rbind "${system_directory_array[2]}" "${chroot_directory_array[2]}"
        \mount --verbose --make-rslave "${chroot_directory_array[2]}"
        \mount --verbose --rbind "${system_directory_array[3]}" "${chroot_directory_array[3]}"
        \mount --verbose --make-rslave "${chroot_directory_array[3]}"

        echo -e "\e[01;33mPrepared the chroot environment.\e[0m\n" >&2
        echo -e "\e[01;33mExecute the following command to enter it: chroot . \"/bin/bash\"\e[0m" >&2
        echo -e "\e[01;33mIf the CPU architectures differ, the binary \"qemu-<arch>-static\" may be used: cp \"qemu-<arch>-static\" \"usr/bin/\" && chroot . qemu-<arch>-static \"/bin/bash\"\e[0m" >&2
        echo -e "\e[01;33mExecute the following command to prepare the environment within the chroot: source \"/etc/profile\" && export PS1=\"(chroot) \${PS1}\"\e[0m" >&2
    else
        echo -e "\e[01;31mEntering a chroot environment requires root privileges!\e[0m" >&2
        return 1
    fi
}
uchroot()
{
    if [[ "${EUID}" == "0" ]]
    then
        declare -a chroot_directory_array
        chroot_directory_array=("./proc/" "./sys/" "./dev/")
        local chroot_directory

        for chroot_directory in "${chroot_directory_array[@]}"
        do
            if [[ ! -d "${chroot_directory}" ]]
            then
                echo -e "\e[01;31mThe chroot directory: '${chroot_directory}' could not be found or is not a directory.\e[0m" >&2
                return 1
            elif ! \mountpoint --quiet "${chroot_directory}"
            then
                echo -e "\e[01;31mThe chroot directory: '${chroot_directory}' is not mounted.\e[0m" >&2
            fi
        done

        \umount --verbose --lazy --recursive ${chroot_directory_array[@]}

        echo -e "\e[01;33mUnprepared the chroot environment.\e[0m" >&2
    else
        echo -e "\e[01;31mUnpreparing a chroot environment requires root privileges!\e[0m" >&2
        return 1
    fi
}

## toggle exclude remove feature via "globbing"
exclude_remove_on()
{
    setopt extended_glob
    echo -e "\e[01;31mGlob syntax has been activated.\e[0m"
    echo "Examples:"
    echo "Remove all files, except the file 'nom': rm -- ^\"nom\""
    echo "Remove all files, except files with the suffix 'png' and 'jpg': rm -- ^.*(png|jpg)"
}
exclude_remove_off()
{
    unsetopt extended_glob
    echo -e "\e[01;31mGlob syntax has been deactivated.\e[0m"
}

## print invoice files in chronological descending order
lpr_invoice()
{
    local directory_file_list=$(\ls -1tr)
    local directory_file
    declare -a invoice_file_array
    local print_files
    local invoice_index_number="1"
    local invoice_index_prefix
    local invoice_page_count

    if [[ "${directory_file_list}" != "" ]]
    then
        echo ""
        while read -r directory_file
        do
            if [[ -f "${directory_file}" ]]
            then
                if (( "${invoice_index_number}" < 10 ))
                then
                    invoice_index_prefix="0"
                else
                    unset invoice_index_prefix
                fi

                invoice_page_count=$(\pdfinfo "${directory_file}" | \awk '/Pages:/ { print $2 }')

                if (( invoice_page_count > 19 ))
                then
                    invoice_page_count="\e[01;31m${invoice_page_count}\e[0m"
                elif (( invoice_page_count > 9 ))
                then
                    invoice_page_count="\e[01;33m${invoice_page_count}\e[0m"
                fi

                invoice_file_array+=("${directory_file}")
                if (( invoice_index_number % 2 == 0 ))
                then
                    echo -e "   \e[01;34m${invoice_index_prefix}${invoice_index_number} (Pages: ${invoice_page_count}\e[01;34m):\t${directory_file}\e[0m"
                else
                    echo -e "   \e[01;37m${invoice_index_prefix}${invoice_index_number} (Pages: ${invoice_page_count}\e[01;37m):\t${directory_file}\e[0m"
                fi
                (( invoice_index_number++ ))
            fi
        done <<< "${directory_file_list}"

        if [[ "${invoice_file_array[@]}" != "" ]]
        then
            read $'print_files?\n\e[01;31mDo you really want to print the above files in chronologically descending order? (y/N): \e[0m' >&2

            case "${print_files:-n}" in
                "y"|"Y")
                    \lpr "${invoice_file_array[@]}"
                    echo -e "\n\e[01;33mDo not forget to sort the printed files chronologically!\e[0m" >&2
                    echo -e "\e[01;33mDo not forget to sort the printed files chronologically!\e[0m" >&2
                    echo -e "\e[01;33mDo not forget to sort the printed files chronologically!\e[0m\n" >&2
                    ;;

                "n"|"N")
                    return 1
                    ;;

                *)
                    echo -e "\e[01;31mWrong input: '${print_files}'.\e[0m" >&2
                    return 1
            esac
        else
            echo -e "\e[01;31mThe invoice file array: '${invoice_file_array[@]}' is empty. Nothing to do...\e[0m" >&2
            return 1
        fi
    else
        echo -e "\e[01;31mThe directory file list: '${directory_file_list}' is empty. Nothing to do...\e[0m" >&2
        return 1
    fi
}

## generate strong passwords with ~130 bit entropy
genpw()
{
    local -i password_length=24
    local remove_characters="[:space:]"
    local -i password_count=20
    local password_output
    local password_entropy
    local entropy_result
    local lowercase_letter_regex="[a-z]"
    local lowercase_letter_amount="26"
    local uppercase_letter_regex="[A-Z]"
    local uppercase_letter_amount="26"
    local numeric_regex="[0-9]"
    local numeric_amount="10"
    local ascii_character_string="[[:punct:]]"
    local ascii_character_amount="32"

    while (( ${#} ))
    do
        case "${1}" in
            "-a" | "--no-lowercase")
                remove_characters+="a-z"
                ;;

            "-A" | "--no-uppercase")
                remove_characters+="A-Z"
                ;;

            "-c" | "--count")
                password_count="${2}"
                shift
                ;;

            "-l" | "--length")
                password_length="${2}"
                shift
                ;;

            "-n" | "--no-numbers")
                remove_characters+="0-9"
                ;;

            "-s" | "--no-special")
                remove_characters+="[:punct:]"
                ;;

            "-h" | "--help")
                echo ""
                echo "Usage: ${0} [options]... <arguments>..."
                echo ""
                echo "OPTIONS:"
                echo "  -a, --no-lowercase              exclude lowercase characters"
                echo "  -A, --no-uppercase              excluce uppercase characters"
                echo "  -c, --count <number>            define the amount of generated passwords"
                echo "  -l, --length <number>           define password length"
                echo "  -n, --no-numbers                exclude numeric characters"
                echo "  -s, --no-special                exclude special characters"
                echo "  -h, --help                      show this message"
                echo ""
                echo "EXAMPLES:"
                echo "  generate a password with 24 characters"
                echo "      ${0} --length 24"
                echo ""
                echo "  exclude special and uppercase characters"
                echo "      ${0} --no-special --no-uppercase"
                return 0
        esac
        shift 1 >/dev/null 2>&1 || break
    done

    for i in {1..${password_count}}
    do
        password_entropy="0"
        password_output=$(\strings --bytes="1" "/dev/urandom" | \tr --delete "${remove_characters}" | \head --bytes="${password_length}")

        if [[ "${password_output}" =~ "${lowercase_letter_regex}" ]]
        then
            # add 26
            (( password_entropy+=lowercase_letter_amount ))
        fi
        if [[ "${password_output}" =~ "${uppercase_letter_regex}" ]]
        then
            # add 26
            (( password_entropy+=uppercase_letter_amount ))
        fi
        if [[ "${password_output}" =~ "${numeric_regex}" ]]
        then
            # add 10
            (( password_entropy+=numeric_amount ))
        fi
        if [[ "${password_output}" =~ "${ascii_character_string}" ]]
        then
            # add 32
            (( password_entropy+=ascii_character_amount ))
        fi

        entropy_result=$(\awk \
            --assign="password_entropy=${password_entropy}" '\
            {
                printf "%.4f", log(password_entropy^$0)/log(2);
            }' <<< "${password_length}")

        printf "%s    %s bit (%s)\n" "${password_output}" "${entropy_result}" "${password_entropy}"
    done
}

## determine last portage synchronisation
getLastPortageSync()
{
    local portage_timestamp_file="/var/db/repos/gentoo/metadata/timestamp.chk"

    if [[ ! -f "${portage_timestamp_file}" ]]
    then
        echo -e "\e[01;31mThe file: '${portage_timestamp_file}' could not be found or is not a file.\e[0m" >&2
        return 1
    else
        local current_unix_time="$(\date +%s)"
        local portage_unix_time="$(\date --date="$(< ${portage_timestamp_file})" +%s)"
        local days_since_last_sync="$(( (${current_unix_time} - ${portage_unix_time}) / 86400.0 ))"
    fi

    if (( ${days_since_last_sync} >= 3.5 && ${days_since_last_sync} < 7 ))
    then
        printf "\e[01;33m[%.2f] days since last portage synchronisation.\e[0m\n" "${days_since_last_sync}"
    elif (( ${days_since_last_sync} >= 7 ))
    then
        printf "\e[01;31;5m[%.2f] days since last portage synchronisation!\e[0m \e[01;31m(execute as root: /root/bin/update.sh)\e[0m\n" "${days_since_last_sync}"
    elif [[ "${1}" == "-v" ]]
    then
        printf "\e[01;34m[%.2f] days since last portage synchronisation.\e[0m\n" "${days_since_last_sync}"
    else
        printf ""
    fi
}

## list all process signals
lsig()
{
    cat <<EOF
 Signal             Standard    Action      Comment
 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 1: SIGHUP          P1990       Term        Hangup detected on controlling terminal or death of controlling process
 2: SIGINT          P1990       Term        Interrupt from keyboard
 3: SIGQUIT         P1990       Core        Quit from keyboard
 4: SIGKILL         P1990       Term        Kill signal
 5: SIGTRAP         P2001       Core        Trace/breakpoint trap
 6: SIGABRT         P1990       Core        Abort signal from abort(3)
 7: SIGBUS          P2001       Core        Bus error (bad memory access)
 8: SIGFPE          P1990       Core        Floating-point exception
 9: SIGKILL         P1990       Core        Illegal Instruction
10: SIGUSR1         P1990       Term        User-defined signal 1
11: SIGSEGV         P1990       Core        Invalid memory reference
12: SIGUSR2         P1990       Term        User-defined signal 2
13: SIGPIPE         P1990       Term        Broken pipe: write to pipe with no readers; see pipe(7)
14: SIGALRM         P1990       Term        Timer signal from alarm(2)
15: SIGTERM         P1990       Term        Termination signal
16: SIGSTKFLT         -         Term        Stack fault on coprocessor (unused)
17: SIGCHLD         P1990       Ign         Child stopped or terminated
18: SIGCONT         P1990       Cont        Continue if stopped
19: SIGSTOP         P1990       Stop        Stop process
20: SIGTSTP         P1990       Stop        Stop typed at terminal
21: SIGTTIN         P1990       Stop        Terminal input for background process
22: SIGTTOU         P1990       Stop        Terminal output for background process
23: SIGURG          P2001       Ign         Urgent condition on socket (4.2BSD)
24: SIGXCPU         P2001       Core        CPU time limit exceeded (4.2BSD); see strlimit(2)
25: SIGXFSZ         P2001       Core        File size limit exceeded (4.2BSD); see strlimit(2)
26: SIGVTALRM       P2001       Term        Virtual alarm clock (4.2BSD)
27: SIGPROF         P2001       Term        Profiling timer expired
28: SIGWINCH          -         Ign         Window resize signal (4.3BSD, Sun)
29: SIGIO             -         Term        I/O now possible (4.2BSD)
30: SIGPWR            -         Term        Power failure (System V)
31: SIGSYS          P2001       Core        Bad system call (SVr4); see also seccomp(2)
32: Not defined       -          -          -
33: Not defined       -          -          -
34: SIGRTMIN        P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
35: SIGRTMIN+1      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
36: SIGRTMIN+2      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
37: SIGRTMIN+3      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
38: SIGRTMIN+4      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
39: SIGRTMIN+5      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
40: SIGRTMIN+6      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
41: SIGRTMIN+7      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
42: SIGRTMIN+8      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
43: SIGRTMIN+9      P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
44: SIGRTMIN+10     P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
45: SIGRTMIN+11     P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
46: SIGRTMIN+12     P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
47: SIGRTMIN+13     P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
48: SIGRTMIN+14     P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
49: SIGRTMIN+15     P2001       (Term)      Real-time signal min; should not exceet SIGRTMAX
50: SIGRTMAX-14     P2001       (Term)      Real-time signal max
51: SIGRTMAX-13     P2001       (Term)      Real-time signal max
52: SIGRTMAX-12     P2001       (Term)      Real-time signal max
53: SIGRTMAX-11     P2001       (Term)      Real-time signal max
54: SIGRTMAX-10     P2001       (Term)      Real-time signal max
55: SIGRTMAX-9      P2001       (Term)      Real-time signal max
56: SIGRTMAX-8      P2001       (Term)      Real-time signal max
57: SIGRTMAX-7      P2001       (Term)      Real-time signal max
58: SIGRTMAX-6      P2001       (Term)      Real-time signal max
59: SIGRTMAX-5      P2001       (Term)      Real-time signal max
60: SIGRTMAX-4      P2001       (Term)      Real-time signal max
61: SIGRTMAX-3      P2001       (Term)      Real-time signal max
62: SIGRTMAX-2      P2001       (Term)      Real-time signal max
63: SIGRTMAX-1      P2001       (Term)      Real-time signal max
64: SIGRTMAX        P2001       (Term)      Real-time signal max

The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.

Up to and including Linux 2.2, the default behavior for SIGSYS, SIGXCPU, SIGXFSZ, and (on architectures other
than SPARC and MIPS) SIGBUS was to terminate the process (without a core dump).  (On some other UNIX  systems
the  default action for SIGXCPU and SIGXFSZ is to terminate the process without a core dump.)  Linux 2.4 con‐
forms to the POSIX.1-2001 requirements for these signals, terminating the process with a core dump.

SIGEMT is not specified in POSIX.1-2001, but nevertheless appears on most other UNIX systems, where  its  de‐
fault action is typically to terminate the process with a core dump.

SIGPWR  (which  is not specified in POSIX.1-2001) is typically ignored by default on those other UNIX systems
where it appears.

SIGIO (which is not specified in POSIX.1-2001) is ignored by default on several other UNIX systems.

See also: man 7 signal
EOF
}

## monitor a single running process
pmon()
{
    local process_name="${1}"
    local watch_interval="${2:-0.1}"
    local process_name_last_character="${process_name:(-1)}"
    local search_string="${process_name/%${process_name_last_character}/[${process_name_last_character}]}"

    # use the command "command watch" and "command ps"
    # in order to use them as unaliased commands.
    # the command "unalias" could be used here, but once executed,
    # this would affect the current shell.
    \watch --differences --interval "${watch_interval}" \
        "\awk --assign search_string="${search_string}" \
            'NR == 1; \$0 ~ search_string' < <(\ps faux)"
}

## follow a single running process and always exit with error code "0"
fpid()
{
    local process_name="${1}"
    declare -a process_id_array
    process_id_array=($(\pgrep "${process_name}"))
    # "zsh"'s array index starts at "1"
    first_process_id="${process_id_array[1]}"

    echo -e "\e[01;34mWaiting for process to exit: '\e[01;33m${process_name}/${first_process_id}\e[0m\e[01;34m'.\e[0m"
    \tail --follow "/dev/null" --pid="${first_process_id}"
    return 0
}

## notify after a command has finished
## usage: notifyme <some_command>
notifyme()
{
    local -i start_time="$(\date +%s)"

    "${@}"

    local end_time="$(\date +%s)"
    local total_execution_time="$(( end_time - start_time ))"
    #if (( total_execution_time >= 15 ))
    #then
        \notify-send --app-name="Notification" --icon="notifications" --urgency="critical" "Command finished [${total_execution_time} seconds]" "'$(echo ${@})'"
    #fi
}

## list real and effective user and group ids in a more convenient way
listids()
{
    declare -a username_array
    username_array=("${@:-${USER}}")
    local username
    declare -A username_id_array
    local username_id
    local id_name_list

    # fill associative array
    for username in "${username_array[@]}"
    do
        id_name_list=$(\id "${username}")

        if [[ "${id_name_list}" == "" ]]
        then
            continue
        else
            username_id_array[${username}]="${id_name_list}"
        fi
    done

    # output associative array
    for username_id in ${(k)username_id_array}
    do
        echo -e "\e[01;34mIDs of the user '\e[01;33m${username_id}\e[0m\e[01;34m':\e[0m"
        \awk --field-separator ',' '{ gsub("[, ]", "\n    "); sub("^", "    "); print $0"\n"}' <<< ${username_id_array[${username_id}]}
    done
}

## bash: execute bell when command is finished
precmd()
{
    eval "${PROMPT_COMMAND}"
}
PROMPT_COMMAND+='tput bel;'

## dynamically change the window title for terminals
if [[ "${TERM}" != "" && "${TERM}" == "st"* || "${TERM}" == "alacritty" ]]
then
    precmd()
    {
        # output on which level (%L) this shell is running on.
        # append the current directory (%~), substitute home directories with a tilde.
        # "\a" bell (man 1 echo)
        # "print" must be used here; echo cannot handle prompt expansions (%L)
        print -Pn "\e]0;${USER}@${HOSTNAME}: zsh[%L] %~\a"
    }

    preexec()
    {
        # output current executed command with parameters
        echo -en "\e]0;${USER}@${HOSTNAME}: ${1}\a"
    }
fi


## list access, owner and group permission tree for the current or defined working directory
ptree()
{
    local directory_path="${1:-$(\pwd)}"
    \namei --long --mountpoints "${directory_path}"
}

## upload files to "transfer.sh"
transfer()
{
    local file
    declare -a file_array
    file_array=("${@}")

    if [[ "${file_array[@]}" == "" || "${1}" == "--help" || "${1}" == "-h" ]]
    then
        echo "${0} - Upload arbitrary files to \"transfer.sh\"."
        echo ""
        echo "Usage: ${0} [options] [<file>]..."
        echo ""
        echo "OPTIONS:"
        echo "  -h, --help"
        echo "      show this message"
        echo ""
        echo "EXAMPLES:"
        echo "  Upload a single file from the current working directory:"
        echo "      ${0} \"image1.img\""
        echo ""
        echo "  Upload multiple files from the current working directory:"
        echo "      ${0} \"image1.img\" \"image2.img\""
        echo ""
        echo "  Upload multiple files with spaces in their filename from the current working directory:"
        echo "      ${0} \"image 1.img\" image\ 2.img"
        echo ""
        echo "  Upload a file from a different directory:"
        echo "      ${0} \"/tmp/image1.img\""
        echo ""
        echo "  Upload multiple files from a different directory:"
        echo "      ${0} transfer /tmp/{image1.img,image\ 1.img,\"image 2.img\"}"
        echo ""
        echo "  Upload all files from the current working directory. Be aware of the webserver's rate limiting!:"
        echo "      ${0} *"
        echo ""
        echo "  Upload a single file from the current working directory and filter out the delete token and download link:"
        echo "      ${0} \"image.img\" | awk --field-separator=\": \" '/Delete token:/ { print \$2 } /Download link:/ { print \$2 }'"
        echo ""
        echo "  Show help text from \"transfer.sh\":"
        echo "      curl --request GET \"https://transfer.sh\""
        return 0
    else
        for file in "${file_array[@]}"
        do
            if [[ ! -f "${file}" ]]
            then
                echo -e "\e[01;31mThe file: '${file}' could not be found or is not a file.\e[0m" >&2
                return 1
            fi
        done
        unset file
    fi

    local upload_files
    local curl_output
    local awk_output
    local url_filename

    \du --total --block-size="K" --dereference "${file_array[@]}" >&2
    # be compatible with "bash"
    if [[ "${ZSH_NAME}" == "zsh" ]]
    then
        read $'upload_files?\e[01;31mDo you really want to upload the above files ('"${#file_array[@]}"$') to "transfer.sh"? (y/N): \e[0m' >&2
    elif [[ "${BASH}" == *"bash"* ]]
    then
        read -p $'\e[01;31mDo you really want to upload the above files ('"${#file_array[@]}"$') to "transfer.sh"? (y/N): \e[0m' upload_files >&2
    fi

    case "${upload_files:-n}" in
        "y"|"Y")
            # for the sake of the progress bar, execute "curl" for each file.
            # the parameters "--include" and "--form" will suppress the progress bar.
            for file in "${file_array[@]}"
            do
                url_filename="${file##*/}"
                url_filename="${url_filename// /%20}"
                # show delete link and filter out the delete token from the response header after upload.
                # it is important to save "curl's" "stdout" via a subshell to a variable or redirect it to another command,
                # which just redirects to "stdout" in order to have a sane output afterwards.
                # the progress bar is redirected to "stderr" and is only displayed,
                # if "stdout" is redirected to something; e.g. ">/dev/null", "tee /dev/null" or "| <some_command>".
                # the response header is redirected to "stdout", so redirecting "stdout" to "/dev/null" does not make any sense.
                # redirecting "curl's" "stderr" to "stdout" ("2>&1") will suppress the progress bar.
                curl_output=$(\curl --request PUT --progress-bar --dump-header - --upload-file "${file}" "https://transfer.sh/${url_filename}")
                awk_output=$(\awk \
                    'gsub("\r", "", $0) && tolower($1) ~ /x-url-delete/ \
                    {
                        delete_link=$2;
                        print "Delete command: curl --request DELETE " "\""delete_link"\"";

                        delete_token=gensub(".*/", "", "g", delete_link);
                        print "Delete token: " delete_token;
                    }

                    END{
                        print "Download link: " $0;
                    }' <<< "${curl_output}")

                # return the results via "stdout", "awk" does not do this for some reason.
                echo -e "${awk_output}\n"

                # avoid rate limiting as much as possible; nginx: too many requests.
                if (( ${#file_array[@]} > 4 ))
                then
                    \sleep 5
                fi
            done
            ;;

        "n"|"N")
            return 1
            ;;

        *)
            echo -e "\e[01;31mWrong input: '${upload_files}'.\e[0m" >&2
            return 1
    esac
}

thingsIalwaysForget()
{
    echo -e "\e[01;34miproute2:\e[0m"
    echo "  Configure a static IP address:"
    echo "      ip address add <local_ip_address>/<cidr_subnet_mask> dev <inferface>"
    echo ""
    echo "  Configure a default gateway:"
    echo "      ip route add default via <default_gateway> dev <interface>"
    echo ""
    echo -e "\e[01;34mTranslations:\e[0m"
    echo "  None."
    echo ""
    echo -e "\e[01;34mPortage:\e[0m"
    echo "  Downgrading a package:"
    echo "      emerge --oneshot \=<package_name>-<major_version>.<minor_version>.<patch_version>"
    echo "      emerge --oneshot \=<package_name>:<major_version>.<minor_version>.<patch_version>"
}

## get current wan ip address
wan()
{
    declare -a ip_version_array
    ip_version_array=("ipv4" "ipv6")
    local ip_version

    for ip_version in "${ip_version_array[@]}"
    do
        echo -n "${ip_version}: "
        \curl --request GET --silent --show-error --"${ip_version}" "https://ifconfig.co/"
    done
}

## get weather forecast information
weather()
{
    local input_string="${*// /+}"

    if [[ "${input_string}" == "--help" || "${input_string}" == "-h" ]]
    then
        input_string=":help"
    fi

    \curl --request GET --silent --show-error "https://wttr.in/${input_string}"
}

## output the paths to binary files from "${PATH}" and functions of the current shell
wherefrom()
{
    declare -a binary_name_array
    binary_name_array=("${@}")
    local binary_name_command
    local binary_name which
    local binary_name_whereis

    #unalias "${binary_name_array[@]}" 2>/dev/null

    echo -e "\e[01;34mOutput of '\e[01;33mcommand -v\e[0m\e[01;34m':\e[0m"
    for binary_name_command in "${binary_name_array[@]}"
    do
        echo "    $(\command -v ${binary_name_command})"
    done

    echo -e "\n\e[01;34mOutput of '\e[01;33mwhich'\e[0m\e[01;34m:\e[0m"
    for binary_name_which in "${binary_name_array[@]}"
    do
        echo -e "\n    $(\which ${binary_name_which})"
    done

    echo -e "\n\e[01;34mOutput of '\e[01;33mwhereis\e[0m\e[01;34m':\e[0m"
    for binary_name_whereis in "${binary_name_array[@]}"
    do
        echo "    $(\whereis ${binary_name_whereis})"
    done

}

## do not include faulty commands in history
zshaddhistory()
{
    whence ${${(z)1}[1]} >| /dev/null || return 1
}

# prompt shell
## colour
#if [[ "${EUID}" == "0" ]]
#then
#    zstyle ':prompt:grml:*:items:user' pre '%F{yellow}'
#else
#    zstyle ':prompt:grml:*:items:user' pre '%F{magenta}'
#fi

# source
## autojump
source "/usr/share/autojump/autojump.zsh"
## zsh-autosuggestions
source "/usr/local/share/git/zsh/zsh-autosuggestions/zsh-autosuggestions.zsh"
## zsh-syntax-highlighting
source "/usr/local/share/git/zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"

# keybindings
bindkey -r "^N" # up-line-or-history
bindkey -r "^P" # down-line-or-history
bindkey "^N" down-line-or-search
bindkey "^P" up-line-or-search

# aliases
alias aria2c="aria2c --enable-rpc='false' \
    --rpc-allow-origin-all='false' \
    --rpc-listen-all='false' \
    --force-sequential='true' \
    --continue='true' \
    --auto-save-interval='30' \
    --http-accept-gzip='true' \
    --netrc-path='${HOME}/.cache/aria2/netrc' \
    --max-concurrent-downloads='4' \
    --max-connection-per-server='8' \
    --min-split-size='20M' \
    --split='8' \
    --save-session='${HOME}/.cache/aria2/aria2_session.gz' \
    --save-session-interval='60' \
    --bt-detach-seed-only='true' \
    --bt-enable-lpd='true' \
    --bt-stop-timeout='21600' \
    --check-integrity='true' \
    --seed-ratio='1.0' \
    --seed-time='0' \
    --enable-dht='true' \
    --enable-dht6='true' \
    --dht-listen-port='6881-6999' \
    --dht-file-path='${HOME}/.cache/aria2/dht.dat' \
    --dht-file-path6='${HOME}/.cache/aria2/dht6.dat' \
    --bt-force-encryption='true' \
    --bt-require-crypto='true' \
    --bt-min-crypto-level='arc4' \
    --bt-max-peers='60' \
    --bt-request-peer-speed-limit='50K' \
    --max-overall-upload-limit='400K' \
    --disable-ipv6='false' \
    --event-poll='epoll' \
    --file-allocation='falloc' \
    --max-download-limit='0' \
    --max-overall-download-limit='0' \
    --optimize-concurrent-downloads='true' \
    --min-tls-version='TLSv1.2' \
    --allow-overwrite='true' \
    --auto-file-renaming='false' \
    --conditional-get='true' \
    --remove-control-file='false'"
alias bc="bc --mathlib"
alias cdrecord="cdrecord -sao -speed='0' -eject -v"
alias crontab="crontab -i"
alias curl="curl --show-error"
alias dd="dd bs='512b' conv='fsync' status='progress'"
alias diff="diff --side-by-side --suppress-common-lines --color"
alias dvdbackup="dvdbackup --progress"
alias fallocate="fallocate --verbose"
alias fping="fping --generate --rdns"
alias growisofs="growisofs -speed='1'"
alias go-mtpfs="echo -e '\e[01;31mRemember to copy all files with only 512KBps!\e[0m\n' &&  go-mtpfs -usb-timeout='15000'"
alias halt="echo 'Are you sure? Please run: /sbin/halt'"
alias htop="btop"
alias hexdump="hexdump --canonical"
alias history="history -i"
alias iotop="iotop --only --processes --accumulated --delay='2'"
alias ip="ip --color"
alias l="ls -vC --classify"
alias la="ls -v --all"
alias lbzip2"lbzp2 --best"
alias listaliases="echo '${(k)aliases// /\n}'"
alias listfunctions="echo '${(k)functions// /\n}'"
alias listgroups="awk --field-separator ':' '{ printf \"Group name: %-20s GID: %-10s Members: %-10s\n\", \$1, \$3, \$4 }' '/etc/group' | sort --numeric-sort --key='5'"
alias listusers="awk --field-separator ':' '{ printf \"Username: %-20s UID: %-10s GID: %-10s Shell: %-10s\n\", \$1, \$3, \$4, \$7 }' '/etc/passwd' | sort --numeric-sort --key='4'"
alias listvariables="echo '${(k)parameters// /\n}'"
alias ll="ls -vl"
alias ln="ln --verbose"
alias locate="locate --ignore-case"
alias lsblk="lsblk --discard --fs --merge --perms --zoned"
alias mkdir="mkdir --parents"
alias mktorrent="mktorrent --verbose \
    --announce='http://tracker.openbittorrent.com:80/announce' \
    --announce='udp://tracker.internetwarriors.net:1337/announce' \
    --announce='udp://tracker.opentrackr.org:1337/announce' \
    --announce='udp://exodus.desync.com:6969/announce' \
    --announce='udp://tracker.tiny-vps.com:6969/announce' \
    --announce='udp://retracker.lanta-net.ru:2710/announce' \
    --announce='udp://tracker.torrent.eu.org:451/announce' \
    --announce='udp://tracker.moeking.me:6969/announce' \
    --announce='udp://vibe.community:6969/announce' \
    --announce='udp://valakas.rollo.dnsabr.com:2710/announce' \
    --announce='udp://tracker0.ufibox.com:6969/announce' \
    --announce='udp://tracker.zerobytes.xyz:1337/announce' \
    --announce='udp://tracker.v6speed.org:6969/announce' \
    --announce='udp://tracker.uw0.xyz:6969/announce' \
    --announce='udp://tracker.shkinev.me:6969/announce' \
    --announce='udp://tracker.nighthawk.pw:2052/announce' \
    --announce='udp://tracker.lelux.fi:6969/announce'"
alias ncdu="ncdu --color='dark' --confirm-quit --exclude-kernfs"
alias nload="nload -u K"
alias path="echo ${PATH//:/'\n'}"
alias poweroff="echo 'Are you sure? Please run: /sbin/poweroff'"
alias pigz="pigz --best"
alias pixz="pixz -9"
alias plzip="plzip --best"
alias ps="ps axo user,group,uid,gid,ppid,pid,pgid,sid,sgid,%cpu,%mem,vsz,rss,tty,stat,start,time,comm,args=ARGS"
alias pstree="pstree --unicode --arguments --highlight-all --show-pids --show-pgids --numeric-sort"
alias radeontop="radeontop --color"
alias rdesktop="rdesktop -g 1920x1080 -P -z -x -l -r sound:off -k '/usr/share/rdesktop/keymaps/de'"
alias reboot="echo 'Are you sure? Please run: /sbin/reboot'"
alias rsync="rsync --archive --hard-links --acls --xattrs --one-file-system --numeric-ids --info='progress2' --rsh='ssh -T -c chacha20-poly1305@openssh.com,aes256-gcm@openssh.com -o Compression=no -x'"
alias shutdown="echo 'Are you sure? Please run: /sbin/shutdown'"
alias shred="shred --verbose"
alias tree="LS_COLORS='' tree -FC"
alias updatedb="updatedb --require-visibility='yes'"
alias vmstat="vmstat --unit='M' --timestamp --wide 2"
alias watch="watch --differences"
alias webcam_live_capture="mpv --demuxer-lavf-format='video4linux2' --profile='low-latency' --demuxer-lavf-o-set=input_format='mjpeg' --untimed 'av://v4l2:/dev/video0'"
alias webcam_record="ffmpeg -f v4l2 -framerate 30 -video_size 1920x1080 -input_format mjpeg -i /dev/video0 -f alsa -i default -c:a aac '$(\date +%Y%m%d)_webcam_record.mkv'"
alias wget="wget --hsts-file='/dev/null'"
alias xargs="xargs --max-procs='$(\nproc --all --ignore="1")' --max-args='1'"
alias xstow="xstow -verbose"
alias zerofree="zerofree -v"
alias zip="zip -9"
alias zstd="zstd --ultra -22 --rm --verbose"
alias zstdmt="zstdmt --ultra -22 --rm --verbose"
if [[ "${EUID}" == "0" ]]
then
    alias pip="echo -e \"\e[01;31m'pip' should not be executed with root privileges!\e[0m\""
fi

# export
## set default text editor
export EDITOR="nvim"
export VISUAL="nvim"
## location for x cache
export XDG_CACHE_HOME="${HOME}/.cache"
## set colours for hard and orphaned symlinks
export LS_COLORS="mh=44;37:or=40;31;01"
## less
### general settings
export LESS="--RAW-CONTROL-CHARS --LONG-PROMPT --shift 5 --ignore-case"
### enable syntax highlighting
export LESSOPEN="| lesspipe.sh %s"
### do not save search entries at "~/.lesshst"
export LESSHISTFILE="/dev/null"
## do not include certain commands in history
export ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE="20"
## do not include critical or annoying commands in history
export HISTORY_IGNORE="(*:*|*--force*|*cd*|*chmod*|*chown*|*clear*|*dd*|*delete*|*exit*|*find*|*for*|*halt*|*kill*|*mkfs*|*ll*|*lpr*|*ls*|*mv*|*perl-rename*|*poweroff*|*pwd*|*reboot*|*rename*|*remove*|*rm*|*sed*|*shred*|*shutdown*|*sudo*|*suspend*|*touch*|*while*)"
## use "ccache" via "distcc". see also "/etc/conf.d/distccd", "/etc/distcc/hosts", "/etc/env.d/03distcc_ccache" and "/etc/portage/make.conf"
export PATH="/usr/lib/ccache/bin:${PATH}"
export CCACHE_DIR="/home/ramon/.var/tmp/ccache"
export DISTCC_DIR="/home/ramon/.var/tmp/distcc"
## mimic bash's cursor movement for paths
### original string: *?_-.[]~=/&;!#$%^(){}<>
export WORDCHARS="*?_-.[]~=&;!#$%^(){}<>"
## always use the best compression method of "xz"
export XZ_OPT="-9"
## workaround for "tmux" to create proper conditionals
export EUID="${EUID}"

# output when opening shell
## list who is logged in
\who --users
## list tmux sessions
if [[ $(\pgrep "tmux") ]]
then
    \tmux ls
fi
## portage
### last synchronisation in days
getLastPortageSync
